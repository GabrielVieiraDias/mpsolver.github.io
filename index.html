<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MathProg</title>
    <script src="libs/FileSaver.js-master/src/FileSaver.js"></script>
    <script src="libs/jQuery/2.2.3/jquery-2.2.3.min.js"></script>
    <script src="libs/jQuery-UI/1.11.4/jquery-ui.min.js"></script>
    <link href="libs/jQuery-UI/1.11.4/jquery-ui.css" rel="stylesheet">
    <script src="libs/Bootstrap/3.3.4/bootstrap.min.js"></script>
    <script src="libs/smartmenus-1.0.0/jquery.smartmenus.min.js"></script>
    <script src="libs/smartmenus-1.0.0/addons/bootstrap/jquery.smartmenus.bootstrap.min.js"></script>
    <link href="libs/Bootstrap/3.3.4/bootstrap.min.css" rel="stylesheet">
    <link href="libs/smartmenus-1.0.0/addons/bootstrap/jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="css/mathprog.css" rel="stylesheet">
    <script src="libs/CodeMirror/5.13.4/codemirror.min.js"></script>
    <link href="libs/CodeMirror/5.13.4/codemirror.min.css" rel="stylesheet">
    <script src="libs/CodeMirror/codemirror_mathprog.js"></script>
    <script src="libs/markdown-it/6.0.1/markdown-it.min.js"></script>
    <link href="libs/KaTeX/0.5.1/katex.min.css" rel="stylesheet">
    <script src="libs/KaTeX/0.5.1/katex.min.js"></script>
    <script src="libs/KaTeX/0.5.1/auto-render.min.js"></script>
    <script src="libs/filepicker.js"></script>
    <script src="libs/jsapi.js"></script>
    <script src='libs/glpk.min.js'></script>
</head>

<body>

    <!-- modal Sobre... -->
    <div id="modalAbout" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="model-content">
                <div class="modal-header">
                    <h3>Sobre...</h3>
                </div>
                <div class="modal-body">
                    <p>
                        <b>MathProg Solver</b> é uma aplicação para otimiza&ccedil;&atilde;o linear e discreta no GNU MathProg, a linguagem de modelagem do projeto GLPK de c&oacute;digo aberto. A sintaxe &eacute; similar a <a href="http://www.ampl.com/"
                            target='_blank'>AMPL</a>. Os c&aacute;lculos são realizados no aplicativo usando o solucionador glpk.js.
                    </p>
                    <p>
                        Este projeto usa bibliotecas de c&oacute;digo aberto, incluindo:
                    </p>
                    <ul>
                        <li> <a href='http://www.gnu.org/software/glpk/' target='_blank'>GNU GLPK project</a></li>
                        <li> <a href='https://github.com/hgourvest/glpk.js' target='_blank'>glpk.js</a></li>
                        <li> <a href='http://jquery.com/' target='_blank'>jQuery</a></li>
                        <li> <a href='http://twitter.github.com/bootstrap/' target='_blank'>Bootstrap</a></li>
                        <li> <a href='https://khan.github.io/KaTeX/' target='_blank'>KaTeX</a></li>
                    </ul>

                    <p>Este projeto foi baseado no projeto disponível no GitHub do jckantor. Link para o projeto original: <a target="_blank" href="https://github.com/jckantor/MathProg-Solver.git">https://github.com/jckantor/MathProg-Solver.git</a></p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" data-dismiss="modal">Fechar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Confirmar limpeza do editor -->
    <div id="modalConfirmClearAll" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Existem altera&ccedil;&otilde;es a serem salvas...</h3>
                </div>
                <div class="modal-body">
                    <p>
                        Voc&ecirc; vai perder todas as suas altera&ccedil;&otilde;es. Tem certeza que deseja limpar o editor?
                    </p>
                </div>
                <div class="modal-footer">
                    <button id='btnModalConfirmClearAll' class="btn" data-dismiss="modal">N&atilde;o salvar altera&ccedil;&otilde;es</button>
                    <button class="btn btn-primary" data-dismiss="modal">Cancelar</button>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleHelloWorld" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Hello World</h3>
                </div>
                <div id="helloWorld" class="modal-body modal-body-example">
<p>

<p>/*# Hello, World</p>

<p>This is one of the simplest MathProg models one can write. Thw `printf` statement prints information to the model output. Note the use of `\n` to separate lines of output.
</p>
<p>
    * The first statement is a comment. MathProg ignores everything on a line following a hash tag `#` * Every statement ends with a semicolon `;` * The end of model is indicated by the `end;` statement. * There is a final new line following the `end;` statement.
</p>
<p>
    Experiment with this simple file. Try adding additional lines of output including blank lines. See what happens if you leave out a needed semicolon or the final `end;` statement.
</p>
On *MathProg Solver* you will find the output under the tab labelled Output. */

<p>
printf "Hello, World!\n";
<p>end;</p>
  
                       
                </div>
                
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExample2variable" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="lpTwoVars" class="modal-body modal-body-example">
                    <p>/*# Linear Program in Two Variables</p>

Write a MathProg model to find the maximum value of \\(z=3x + 4y\\) subject to the following set of constraints
                    
<p>
\\[x + 2y \leq 14 \\]<br> \\[3x - y \geq 0 \\]<br> \\[x - y \leq 2 \\]<br>
</p>
<p>
The maximum value of \\(z\\) is 34. What are the corresponding values of \\(x\\) and \\(y\\)? What is the minimum value of \\(z\\)? */
</p>
<p>
# Define Variables<br>
var x;<br> var y;
</p>
<p>
# Define Constraints
s.t. A: x + 2*y &lt;= 14;<br>
s.t. B: 3*x - y >= 0;<br>
s.t. C: x - y &lt;= 2;<br>

# Define Objective<br>
maximize z: 3*x + 4*y;<br>

# Solve<br>
solve;<br>

end;

                    </p>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleLinearEqns" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="linearEqns" class="modal-body modal-body-example">
<p>/* # Solving a System of Linear Equations MathProg is a language for describing linear and discrete optimization problems. A series of exercises described below will introduce MathProg by demonstrating how to solve to small system
of linear equations. Consider a set of three linear equations
</p>

<p>
\\[ 2x + y + z = 12\\]<br> \\[ x + 2y + z = 23 \\]<br> \\[ x + y + z = 10 \\]<br>
</p>
<p>
in the three unknowns \\(x\\), \\(y\\), and \\(z\\).<br> To find a solution with MathProg you need to create a description of the problem. For this case the description consists of<br>
</p>
<p>
1. a description of the variables,<br> 
2. a description of the equations,<br> 
3. additional keywords indicating the desired actions, and <br> 
4. comments necessary for someone to understand the description. <br> These points are demonstrated in the MathProg model shown below. 
<br><br> Note the following points as you examine this model &mdash;
<br><br> * The hashtags denote comments. Anything following the hashtag on the same line is ignored by MathProg.<br>
* Semicolons separate statements in MathProg. A MathProg statement may continue over several lines.<br> 
* The statements starting with the keyword `var` describe variables appearing in the problem. There is a separate line for
each variable.<br> 
* The next group of statements describe equations appearing in the problem. 
Each statement begins with a name of an equation separated by a colon from the equation itself. The equations are written in standard
computer notation. Each equation must have a name.<br> * The keyword `solve` indicates a solution is to be computed.<br> 
* The keyword `end` indicates completion of the problem description.<br><br> Here are a few exercises to try
<br><br> 
1. Click the Solve button underneath the editor. Locate the solution for \\(x\\),
<br> \\(y\\), and \\(z\\) in the tab labeled 'Variables'. In the constraints tab locate<br> 
the solution for each equation.<br> 
2. Change the equations. Explore how the solution changes depends on equation<br> 
parameters. See what happens when two of the equations are identical.<br> 
3. The Wikipedia page [Systems of Linear Equations](http://en.wikipedia.org/wiki/System_of_linear_equations)
showes some example problems. Click `New Model`, then write a MathProg model from scratch to solve one of the examples.<br> */
</p>
<p>
<b>

# List the variables<br>
var x;<br>
var y;<br>
var z;<br>

# List the equations<br>
Eq1:  2*x +   y +  z = 12;<br>
Eq2:    x + 2*y +  z = 23;<br>
Eq3:    x +   y +  z = 10;<br><br>

# Solve<br>
solve;<br><br>

end;<br>

</b>
                    </p>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleSets" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="sets" class="modal-body modal-body-example">
<p>/* # Set Operations in MathProg</p>

<p>Sets are a basic concept in mathematical programming languages. 
Sets are used to define the objects of discourse in a particular application. 
A convenient notation to is name sets in all caps so they are readily distinguished from
variables and parameters appearing in an application.
</p>
<p>This example demonstrates several basic and useful set manipulations in MathProg:
</p>
<p>
* `union`: the union of sets<br> 
* `card` : the cardinality (i.e, number of elements) of a set<br> 
* : intersection of sets<br> * : difference of sets<br> 
* : symmetric difference of sets<br> */
</p>
<p>
<b>
set DOGS := {'Beagle','Labrador','Shepherd','Boxer'};<br>
set CATS := {'Tiger','Lion'};<br>
set FISH := {'Goldfish','Guppy','Shark'};<br>

# Union of Sets<br>

set PETS := DOGS union CATS union FISH;<br>

printf "PETS: ";<br>
for {pet in PETS} printf "%4s ", pet;<br>

# Cardinality of a Set<br>

printf "\n\nNumber of Pets: %d", card(PETS);<br>

set DANGEROUS := {'Tiger','Lion','Shark','Crocodile'};<br>

# Intersection<br>

# Difference of Sets<br>
set SAFE := PETS diff DANGEROUS;<br>

printf "\n\nSAFE: ";<br>

for {pet in SAFE} printf "%4s ",pet;<br>

# Symmetric Difference of Sets<br>

printf "\n\n";<br>
end;
</b>
                    </p>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleParameters" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="parameters" class="modal-body modal-body-example">
<p>/* # Working with Parameters */</p>

<p>/* Define sets */</p>
<p>
set STUDENTS; 
set COURSES;<br>
</p>
<p>
/* Declare Parameters */<br>
<br> param credits{c in COURSES} >= 0;
<br> param schedules{s in STUDENTS, c in COURSES} binary;<br>
</p>
<p>


/* Computed Parameter */
<br><br> param loads{s in STUDENTS} := sum{c in COURSES} schedules[s,c]*credits[c];<br><br> 
/* Report Results */
<br><br> printf "STUDENTS\n";
<br> printf {student in STUDENTS} " %-10s %3d \n",student,loads[student];<br><br>
printf "\nCOURSES\n";<br> printf {c in COURSES} " %s\n",c;
<br> printf "\n\n";

<br><br> /* Data Section */
<br><br> data;

<br><br> set STUDENTS := Alex Brian Carl Diane Emil Francine;
<br> set COURSES := Math English Chemistry Physics;
<br><br>

param credits :=
<br> Math 3
<br> English 3
<br> Chemistry 4
<br> Physics 5 ;

param schedules: Math English

Chemistry Physics :=

Alex        1  1  0  0
Brian       0  0  1  1
Carl        1  0  0  1 
Diane       0  1  1  1
Emil        1  0  1  0  
Francine    0  1  1  0 ;

<br><br> end;

<br>
</p>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleChartTools" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="chartTools" class="modal-body modal-body-example">
/* # Chart Tools

The table driver GCHART creates charts using Google Chart Tools. The chart
options are specified using the MathProg table syntax 
    
        table tname {x in X} OUT "GCHART" title chartType options : x~fld, y[x]~Y, ...
    
    where 
    
        title: A required string to be used a title of the chart
    chartType: An optional string specifying the chart type.  Consult the Google
                Chart Tools documentation for a list of valid types.
        options: An optional string in JSON format of options. Consult the Google
                Chart Tools for documentation.
    
    Consult the GMPL Language Reference for details regarding MathProg's table
    statement.
*/
        
# Line Chart - Simple, no options
table t01 {x in 0..10 by 0.1} OUT "GCHART" "Mathematical Functions" "LineChart" : 
    x~Radians, sin(x), cos(x);

# Table - Create
set MONTHS;
param Temp{MONTHS};
param Precip{MONTHS};
table t03 {m in MONTHS} OUT "GCHART" "Weather Data for International Falls, MN, USA" "Table":
    m~Month, Temp[m]~Temperature, Precip[m]~Precipitation;

# Column Chart with options
param t04_options symbolic := "{vAxis: {title: 'Temperature (C)'}}";
table t04 {m in MONTHS} OUT "GCHART" "International Falls, MN, USA" "ColumnChart" t04_options: 
    m~Month, (5/9)*(Temp[m]-32)~Temperature;
    
# Bar Chart
table t05 {m in MONTHS} OUT "GCHART" "International Falls, MN, USA" "BarChart"
    "{height: 400}": m~Month, Temp[m]~Temperature;

# Combo Chart
param cc_options symbolic := """
    { legend: {position: 'in'},
        seriesType: 'bars',
        vAxes: {0: {title: 'Temperature (F)'}, 
                1: {title: 'Precipitation (in)'}},
        series: {0: {type: 'bar'}, 
                1: {type: 'area', targetAxisIndex: 1}}
    }  """;
table tab6 {m in MONTHS} OUT "GCHART" "International Falls, MN, USA" "ComboChart" cc_options: 
    m~Month, 
    Temp[m]~Temperature,
    Precip[m]~Precipitation;
    
# Pie Chart
table t07 {m in {'Jun','Jul','Aug'}} OUT "GCHART" "Summer Precipitation" "PieChart" : 
    m~Month, Precip[m]~Precipitation;

# Scatter Chart with Options
param sc_options symbolic := """
    { vAxis: {title: 'Temperature (F)'},
        hAxis: {title: 'Precipitation (inches)'},
        height: 480, 
        width: 640 } """;
table t08 {m in MONTHS} OUT "GCHART" "Precipitation vs. Temperature" "ScatterChart" sc_options: 
    Temp[m]~Temperature,
    Precip[m]~Precipiation;
    
# Gauge 
set DATA := {'AveTemp (F)', 'AnnPrecip (in)'};
var x{DATA};
s.t. A: x['AveTemp (F)'] = (sum {m in MONTHS} Temp[m])/card(MONTHS);
s.t. B: x['AnnPrecip (in)'] = sum {m in MONTHS} Precip[m];
solve;
table tab9 {d in DATA} OUT "GCHART" "Annual Weather Summary" "Gauge" : d, x[d];
    
# Geo Chart - Regions
set BRIC := {'Brazil','Russia','India','China'};
table tab10 {s in BRIC} OUT "GCHART" "BRIC Countries" "GeoChart" : s, Uniform(1,2)~Data;

# Geo Chart - Markers
set ACC := {
    'Atlanta','Blacksburg','Boston','Chapel Hill','Charlottesville',
    'Clemson','College Park','Durham','Miami','Pittsburgh','Syracuse',
    'Raleigh','South Bend','Tallahassee','Winston-Salem'};
param g_options symbolic := """
    { region: 'US',
        displayMode: 'markers',
        colorAxis: {colors: ['green', 'blue']} }""";
table tab11 {s in ACC} OUT "GCHART" "Atlantic Coast Conference" "GeoChart" g_options: s, 1~Data;

data;

param : MONTHS : Temp Precip :=
        Jan       1.0      0.9
        Feb       7.7      0.6
        Mar      22.1      1.1
        Apr      39.0      1.6
        May      52.1      2.5
        Jun      61.4      3.9
        Jul      66.7      3.6
        Aug      63.7      3.1
        Sep      53.4      3.1
        Oct      42.4      2.0
        Nov      24.9      1.1
        Dec       7.2      0.8 ;
    
end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleProjectCPM" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="projectCPM" class="modal-body modal-body-example">
/* # Project Management with the Critical Path Method

The Critical Path Method is a technique for calculating the shortest time span 
    needed to complete a series of tasks. The tasks are represented by nodes, each 
    labelled with the duration. The precedence order of the task is given by a set 
    of arcs.

Here we demonstrate the representation and calculation of the critical path. 
    Decision variables are introduced for

* Earliest Start
* Earliest Finish
* Latest Start
* Latest Finish
* Slack = Earliest Finish - Earliest Start = Latest Finish - Earliest  Finish

Tasks on the Critical Path have zero slack.
*/

set TASKS;
set ARCS within {TASKS cross TASKS};

/* Parameters are the durations for each task */
param dur{TASKS} >= 0;

/* Decision Variables associated with each task*/
var Tes{TASKS} >= 0;     # Earliest Start
var Tef{TASKS} >= 0;     # Earliest Finish
var Tls{TASKS} >= 0;     # Latest Start
var Tlf{TASKS} >= 0;     # Latest Finish
var Tsl{TASKS} >= 0;     # Slacks

/* Global finish time */
var Tf >= 0;

/* Minimize the global finish time and, secondarily, maximize slacks */
minimize ProjectFinish : card(TASKS)*Tf - sum {j in TASKS} Tsl[j];

/* Finish is the least upper bound on the finish time for all tasks */
s.t. Efnsh {j in TASKS} : Tef[j] &lt;= Tf;
s.t. Lfnsh {j in TASKS} : Tlf[j] &lt;= Tf;

/* Relationship between start and finish times for each task */
s.t. Estrt {j in TASKS} : Tef[j] = Tes[j] + dur[j];
s.t. Lstrt {j in TASKS} : Tlf[j] = Tls[j] + dur[j];

/* Slacks */
s.t. Slack {j in TASKS} : Tsl[j] = Tls[j] - Tes[j];

/* Task ordering */
s.t. Eordr {(i,j) in ARCS} : Tef[i] &lt;= Tes[j];
s.t. Lordr {(j,k) in ARCS} : Tlf[j] &lt;= Tls[k];

/* Compute Solution  */
solve;

/* Print Report */
printf 'PROJECT LENGTH = %8g\n',Tf;

/* Critical Tasks are those with zero slack */

/* Rank-order tasks on the critical path by earliest start time */
param r{j in TASKS : Tsl[j] = 0} := sum{k in TASKS : Tsl[k] = 0}
    if (Tes[k] &lt;= Tes[j]) then 1;

printf '\nCRITICAL PATH\n';
printf '    TASK    DUR     Start    Finish\n';
printf {k in 1..card(TASKS), j in TASKS : Tsl[j]=0 && k==r[j]}
    '%8s %6g  %8g  %8g\n', j, dur[j], Tes[j], Tef[j];

/* Noncritical Tasks have positive slack */

/* Rank-order tasks not on the critical path by earliest start time */
param s{j in TASKS : Tsl[j] > 0} := sum{k in TASKS : Tsl[k] = 0}
    if (Tes[k] &lt;= Tes[j]) then 1;

printf '\nNON-CRITICAL TASKS\n';
printf '                 Earliest  Earliest    Latest    Latest \n';
printf '    TASK    DUR     Start    Finish     Start    Finish     Slack\n';
printf {k in 1..card(TASKS), j in TASKS : Tsl[j] > 0 && k==s[j]}
    '%8s %6g  %8g  %8g  %8g  %8g  %8g\n', 
    j,dur[j],Tes[j],Tef[j],Tls[j],Tlf[j],Tsl[j];
printf '\n';

data;

/* Stadium Construction Example from Christelle Gueret, Christian Prins, 
Marc Sevaux, "Applications of Optimization with Xpress-MP," Chapter 5,
Dash Optimization, 2000. */ 

param : TASKS : dur :=
    T01   2.0
    T02  16.0
    T03   9.0
    T04   8.0
    T05  10.0
    T06   6.0
    T07   2.0
    T08   2.0
    T09   9.0
    T10   5.0
    T11   3.0
    T12   2.0
    T13   1.0
    T14   7.0
    T15   4.0
    T16   3.0
    T17   9.0
    T18   1.0 ;

set ARCS := 
    T01  T02
    T02  T03
    T02  T04
    T02  T14
    T03  T05
    T04  T07
    T04  T10
    T04  T09
    T04  T06
    T04  T15
    T05  T06
    T06  T09
    T06  T11
    T06  T08
    T07  T13
    T08  T16
    T09  T12
    T11  T16
    T12  T17
    T14  T16
    T14  T15
    T17  T18 ;

end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleJobShop" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="jobShop" class="modal-body modal-body-example">
/* # Job Shop Scheduling

A simple job shop consists of a set of different machines that process jobs. 
Each job consists of series of tasks that must be completed in specified order
on the machines. The problem is to schedule the jobs on the machines to minimize 
makespan.

Data consists of two tables. The first table is decomposition of the jobs into
a series of tasks. Each task lists a job name, name of the required machine, 
and task duration.  The second table list task pairs where the first task must 
be completed before the second task can be started. This formulation is quite 
general, but can also specify situations with no feasible solutions.
*/

/* Data Table 1. Tasks consist of Job, Machine, Dur data*/
set TASKS dimen 2;
param dur{TASKS};

/* Data Table 2 */
set TASKORDER within {TASKS,TASKS};

/* JOBS and MACHINES are inferred from the data tables*/
set JOBS := setof {(j,m) in TASKS} j;
set MACHINES := setof {(j,m) in TASKS} m;

/* Decision variables are start times for tasks, and the makespan */
var start{TASKS} >= 0;
var makespan >= 0;

/* BigM is set to be bigger than largest possible makespan */
param BigM := 1 + sum {(j,m) in TASKS} dur[j,m];

/* The primary objective is to minimize makespan, with a secondary
objective of starting tasks as early as possible */
minimize OBJ: BigM*makespan + sum{(j,m) in TASKS} start[j,m];

/* By definition, all jobs must be completed within the makespan */
s.t. A {(j,m) in TASKS}: start[j,m] + dur[j,m] &lt;= makespan;

/* Must satisfy any orderings that were given for the tasks. */
s.t. B {(k,n,j,m) in TASKORDER}: start[k,n] + dur[k,n] &lt;= start[j,m];

/* Eliminate conflicts if tasks are require the same machine */
/* y[i,m,j] = 1 if Job i is scheduled before job j on machine m*/
var y{(i,m) in TASKS,(j,m) in TASKS: i &lt; j} binary;
s.t. C {(i,m) in TASKS,(j,m) in TASKS: i &lt; j}:
    start[i,m] + dur[i,m] &lt;= start[j,m] + BigM*(1-y[i,m,j]);
s.t. D {(i,m) in TASKS,(j,m) in TASKS: i &lt; j}:
    start[j,m] + dur[j,m] &lt;= start[i,m] + BigM*y[i,m,j];

solve;

printf "Makespan = %5.2f\n",makespan;

/* Post solution, compute finish times for each task to use in report */
param finish{(j,m) in TASKS} := start[j,m] + dur[j,m];

/* Task Summary Report */
printf "\n                TASK SUMMARY\n";
printf "\n     JOB   MACHINE     Dur   Start  Finish\n";
printf {(i,m) in TASKS} "%8s  %8s   %5.2f   %5.2f   %5.2f\n", 
    i, m, dur[i,m], start[i,m], finish[i,m];

/* Schedule of activities for each job */
set M{j in JOBS} := setof {(j,m) in TASKS} m;
param r{j in JOBS, m in M[j]} := 
    1+sum{n in M[j]: start[j,n] &lt; start[j,m] || start[j,n]==start[j,m] && n &lt; m} 1;
printf "\n\n           JOB SCHEDULES\n";
for {j in JOBS} {
    printf "\n%s:\n",j;
    printf "         MACHINE   Start   Finish\n";
    printf {k in 1..card(M[j]), m in M[j]: k==r[j,m]} 
        " %15s   %5.2f    %5.2f\n",m, start[j,m],finish[j,m];
}

/* Schedule of activities for each machine */
set J{m in MACHINES} := setof {(j,m) in TASKS} j;
param s{m in MACHINES, j in J[m]} := 
    1+sum{k in J[m]: start[k,m] &lt; start[j,m] || start[k,m]==start[j,m] && k &lt; j} 1;
printf "\n\n         MACHINE SCHEDULES\n";
for {m in MACHINES} {
    printf "\n%s:\n",m;
    printf "             JOB   Start   Finish\n";
    printf {k in 1..card(J[m]), j in J[m]: k==s[m,j]} 
        " %15s   %5.2f    %5.2f\n",j, start[j,m],finish[j,m];
}

data;

/* Job shop data from Christelle Gueret, Christian Prins,  Marc Sevaux,
"Applications of Optimization with Xpress-MP," Chapter 5, Dash Optimization, 2000. */

/* Jobs are broken down into a list of tasks (j,m), each task described by
job name j, machine name m, and duration dur[j,m] */

param: TASKS: dur :=
    Paper_1  Blue    45
    Paper_1  Yellow  10
    Paper_2  Blue    20
    Paper_2  Green   10
    Paper_2  Yellow  34
    Paper_3  Blue    12
    Paper_3  Green   17
    Paper_3  Yellow  28 ;

/* List task orderings (k,n,j,m) where task (k,n) must proceed task (j,n) */

set TASKORDER :=
    Paper_1 Blue    Paper_1 Yellow
    Paper_2 Green   Paper_2 Blue
    Paper_2 Blue    Paper_2 Yellow
    Paper_3 Yellow  Paper_3 Blue
    Paper_3 Blue    Paper_3 Green ;

end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleJesuit" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="Jesuit" class="modal-body modal-body-example">/* # Jesuit Volunteer Corps

The following problem was formulated by Tomas C. (ND '09) who was working with 
the Jesuit Volunteer Corp in 2009-2010. Here was his problem:

> There are 7 of us in the house. We have broken down the chores into 4 
> major sections: 1) Kitchen, 2) Bathroom, 3) Common Area, 4) Trash. The 
> trash is the only task that needs only one person to accomplish, the 
> other 3 tasks have 2 people assigned to them. Each person needs to rotate
> through each task twice and the trash only once. The assignments rotate 
> each week. Each person needs to have a new partner each week and no 
> person can have more than one task in a week.

In the formulation below we require every possible pair to do at least one task 
together. This is different that requiring a new partner each week, but Tomas
said later that this would meet their needs.

This a challenging computation, depending on your computer this may take a few seconds
to a few minutes to complete a solution.
*/

/* Number of weeks to schedule */
param T :=  7;

/* Numeric labels for volunteers facilitate creating non-replicated pairs */
set VOLS := 1..7;
set TASKS := {'Kitchen', 'Bathroom', 'Commons', 'Trash'};
set WEEKS := 1..T;

/* Compute all pairs of volunteers */
set PAIRS := setof{u in VOLS, v in VOLS: u &lt; v} (u,v);

/* x[v,t,w] = 1 if volunteer v is assigned task t in week w */
var x{v in VOLS, t in TASKS, w in WEEKS} binary;

/* p[u,v,t,w] = 1 if volunteers u and v are paired together on t in week w */
var p{(u,v) in PAIRS, t in TASKS, w in WEEKS} binary;

/* The objective will be the number of times anyone has to do the trash */
var z integer;

minimize obj: z;

/* Each volunteer each week must be assigned one task */
s.t. fa{v in VOLS, w in WEEKS}: sum {t in TASKS} x[v,t,w] = 1;

/* Except for Trash, each task each week must be assigned two volunteers */
s.t. fb{w in WEEKS}: sum {v in VOLS} x[v,'Trash',w] = 1;
s.t. fc{t in TASKS, w in WEEKS : t &lt;> 'Trash'}: sum {v in VOLS} x[v,t,w] = 2;

/* Each volunteer must cycle through each task twice (except trash) */
s.t. fd{t in TASKS, v in VOLS : t &lt;> 'Trash'}: sum {w in WEEKS} x[v,t,w] >= 2;

/* Minimize number of times anyone has to do trash */
s.t. fz{v in VOLS}: sum {w in WEEKS} x[v,'Trash',w] &lt;= z;

/* Pair p(u,v,t,w) is 1 if u and v worked together on Week w and Task t */
s.t. ga{t in TASKS, w in WEEKS, (u,v) in PAIRS}: p[u,v,t,w] &lt;= x[u,t,w];
s.t. gb{t in TASKS, w in WEEKS, (u,v) in PAIRS}: p[u,v,t,w] &lt;= x[v,t,w];
s.t. gc{t in TASKS, w in WEEKS, (u,v) in PAIRS}: 
p[u,v,t,w] >= x[u,t,w] + x[v,t,w] - 1;

/* Each possible pair must do at least one task together. */
s.t. gd{(u,v) in PAIRS}: sum{t in TASKS, w in WEEKS} p[u,v,t,w] >= 1;

solve;

printf "Volunteer Assignments by Weeks";
for {w in WEEKS}{
printf "\n\nWeek: %2s\n",w;
printf "Volunteer:";
printf {v in VOLS} "%3s",v;
for {t in TASKS}{
    printf "\n%9s:",t;
    printf {v in VOLS} "%3s", if x[v,t,w]=1 then "X" else "-";
}
}

printf "\n\n\n Analysis of Volunteer Pairs";
for{(u,v) in PAIRS}{
printf "\n\nPair: (%s,%s)\n",u,v;
printf "     Week:";
printf {w in WEEKS} "%3s",w;
for {t in TASKS}{
    printf "\n%9s:",t;
    printf {w in WEEKS} "%3s", if p[u,v,t,w]=1 then "X" else "-";
}
}

end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTransportationNetwork" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="transportationNetwork" class="modal-body modal-body-example">
/* # Transportation Network

This is a simple model to demonstrate modeling of a transportation 
    network for a system with sources and destinations. The given supply and
    demand constraints, the objective is to minimize transportation costs. 
    This model demonstrates:

* Transportation optimization.
* Factoring of applications into separate modeling and data sections.
* Use of defaults and defining sets in the data section.
*/

/* Model  Section */

set SOURCES;
set CUSTOMERS;

param Demand {CUSTOMERS} >= 0;
param Supply {SOURCES}   >= 0;
param Tcost {CUSTOMERS, SOURCES} default 1000;

var x {CUSTOMERS, SOURCES} >= 0;

/* Minimize total shipping costs */
minimize Cost: sum{c in CUSTOMERS, s in SOURCES} Tcost[c,s]*x[c,s];

/* Total shipped from each source must be less than source capacity */
s.t. SRC {s in SOURCES}: sum {c in CUSTOMERS} x[c,s] &lt;= Supply[s];

/*  Total received must equal customer demand */
s.t. DST {c in CUSTOMERS}: sum {s in SOURCES} x[c,s] = Demand[c];

solve;

data;
/* 
Problem Data from Chapter 5 of Johannes Bisschop, "AIMMS Optimization Modeling",
Paragon Decision Sciences, 1999. The following data details supply, demand, and
shipping costs among a set of 8 European cities
*/

param: CUSTOMERS: Demand :=
    Lon   125        # London
    Ber   175        # Berlin
    Maa   225        # Maastricht
    Ams   250        # Amsterdam
    Utr   225        # Utrecht
    Hag   200 ;      # The Hague

param: SOURCES: Supply :=
    Arn   550        # Arnhem
    Gou   650 ;      # Gouda

param Tcost : Arn   Gou :=
    Lon        .    2.5
    Ber       2.5    .
    Maa       1.6   2.0
    Ams       1.4   1.0
    Utr       0.8   1.0
    Hag       1.4   0.8 ;

end;   
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleStockCutting" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="stockCutting" class="modal-body modal-body-example">
                    /* # Stock Cutting

The stock cutting problem is to minimize the waste associated with cutting up stock
materials to produce a set of products. Examples of the one dimensional problem include
cutting lengths of steel bar into a set of products, cutting wide paper rolls into
smaller ones, and cutting dimensioned lumber to meet the production needs of furniture
shops.

In large scale applications the stock cutting problem begins with a base set of cutting
patterns. Each cutting pattern breaks a piece of stock into a set of products. The base
calculation is to find a mix of cutting patterns to meet product requirements. A
secondary problem is solved to find additional cutting patterns with the potential to
reduce costs. The solution then proceeds iteratively with new patterns are generated 'on
the fly' coupled with a branch and bound search to find an optimal solution. This
approach is called 'column generation.'

As demonstrated below, for small scale problems the stock cutting problem can be 
formulated as an assignment of product pieces to stock pieces. For this example the data 
consists of a list of product types, lengths and demand. The example incorporates 
multiple types of raw materials. The objective is to maximize the number of pieces of 
stock material that are left uncut.

An aspect of this problem is the high degree of solution symmetry. The number of 
equivalent solutions is a combinatorial function of the number of identical pieces of raw 
of materials. In these cases a solver may quickly find a solution but then need to search 
many equivalent solutions to verify optimality. This example uses a weighted objective to 
separate otherwise equivalent solutions.

To repeat, this approach will not work for larger problems due to the excessive number of 
binary variables required and high degree of solution symmetry. Consult the <a 
href="https://code.google.com/p/cspsol/">cspsol project</a> for a solution method using 
column generation and glpk api.
*/

# Products
set PRODUCTS;
param pLength{PRODUCTS};
param demand{PRODUCTS};

# Raw Materials
set RAWMATERIALS;
param rLength{RAWMATERIALS};
param avail{RAWMATERIALS};

# Big M should be greater than the length of any stock piece
param bigM;
check {r in RAWMATERIALS} : bigM > rLength[r];

# Create indexed sets enumerating all production pieces
set Q{p in PRODUCTS} := 1..demand[p] ;

# Create indexed sets enumerating all raw material pieces
set S{r in RAWMATERIALS} := 1..avail[r];

# y[p,q,r,s] = 1 assigns (product p, piece q) to (raw material r, piece s)
var y{p in PRODUCTS, q in Q[p], r in RAWMATERIALS, s in S[r]} binary;

# u[r,s] = 1 indicates use of (raw material r, piece s)
var u{r in RAWMATERIALS, s in S[r]} binary;

# w[r,s] is the remainder left over from (raw material r, piece s)
var w{r in RAWMATERIALS, s in S[r]} >= 0;

# Assign product (p,q) only once to the set of all raw materials (r,s)
s.t. A{p in PRODUCTS, q in Q[p]} : sum{r in RAWMATERIALS, s in S[r]} y[p,q,r,s] = 1;

# Cut enough pieces to exactly meet the demand for each product
s.t. B{p in PRODUCTS} : sum{q in Q[p], r in RAWMATERIALS, s in S[r]} y[p,q,r,s] = demand[p];

# Do not exceed the length each piece of raw material
s.t. C{r in RAWMATERIALS, s in S[r]} : 
    sum{p in PRODUCTS, q in Q[p]} pLength[p]*y[p,q,r,s] + w[r,s] = rLength[r];
    
# Determine if a piece (r,s) of raw material is used.
s.t. D{r in RAWMATERIALS, s in S[r]} : bigM*u[r,s] >= sum{p in PRODUCTS, q in Q[p]} y[p,q,r,s];

minimize Pieces : sum{r in RAWMATERIALS, s in S[r]} rLength[r]*s*u[r,s];

solve;

table products {p in PRODUCTS} OUT "JSON" "Products" "Table" : 
    p~Product, pLength[p]~Length, demand[p]~Demand;

table rawmaterials {r in RAWMATERIALS} OUT "JSON" "Raw Materials" "Table" : 
    r~Raw_Materials, rLength[r]~Length, avail[r]~Available;

printf "Cutting Plan\n";
for {r in RAWMATERIALS} : {
    printf "    Raw Material %s \n", r;
    for {s in S[r]} : {
        printf "        Piece %s-%d : Remainder = %5.2f : Cut product pieces ", r,s, w[r,s];
        for {p in PRODUCTS} : {
            for {q in Q[p] : y[p,q,r,s]} : {
                printf "%s-%d ", p, q;
            }
        }
        printf "\n";
    }
    printf "\n";
}

printf "Production Plan\n";
for {p in PRODUCTS} : {
    printf "    Product %s \n", p;
    for {q in Q[p]} : {
        printf "        Piece %s-%d : Cut from stock piece ", p, q;
        for {r in RAWMATERIALS} : {
            for {s in S[r] : y[p,q,r,s]} : {
                printf "%s-%d ", r, s;
            }
        }
        printf "\n";
    }
    printf "\n";
}

data;

param bigM := 20;

param: PRODUCTS: pLength demand :=
        '7m'        7        3
        '6m'        6        2
        '4m'        4        6
        '3m'        3        1 ;
  
param: RAWMATERIALS: rLength avail := 
       '15m'       15        3
       '10m'       10        3 ;
  
end;

                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTableSeating" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="tableSeating" class="modal-body modal-body-example">
/* # Table Seating

Problem from the lp_solve listserv, January 12, 2013

> I am trying write an integer program to solve the following problem. There are 3n
> people, who are denoted {a,b,c,...}. There are n tables and 3 people must sit at 
> each table. There is a value associated with each pair sitting at the same table.
> Person a and person b sitting together is represented by a binary variable
> a_b and the value of them sitting together is vab.
>
> I want find an allocation of people to tables that maximizes the sum of these values,
> that is max:+vab*a_b+vac*a_c+vad*a_d+....

Be careful. The computational effort required for this prolbem grows
quickly with N and TABLE_SIZE. Until html 5 worker threads are implemented,
this may lock up your browser during the lengthy solution.
*/

param N_TABLES := 4;
param TABLE_SIZE := 3;

set TABLES := 1..N_TABLES;
set PEOPLE := 1..TABLE_SIZE*N_TABLES;
set PAIRS := {p in PEOPLE, q in PEOPLE : q > p};

var x{PEOPLE,TABLES} binary;
var y{PAIRS} binary;

/* Assignment Constraints */
s.t. TablesAreFull{t in TABLES}: sum{p in PEOPLE} x[p,t] = 3;
s.t. SOS {p in PEOPLE}: sum{t in TABLES} x[p,t] = 1;

/* Who is sitting with whom */
s.t. W1 {t in TABLES, (p,q) in PAIRS}: y[p,q] >= x[p,t] + x[q,t] - 1;
s.t. W2 {p in PEOPLE}: 
    (sum{q in 1..(p-1)} y[q,p]) + (sum{q in (p+1)..card(PEOPLE)} y[p,q])
    = TABLE_SIZE - 1;

maximize obj: sum{(p,q) in PAIRS} y[p,q];

solve;

printf "Table Assignments\n";
printf "          ";
printf {p in PEOPLE}: "  %2d", p;
printf "\n";
for {t in TABLES}: {
    printf "Table(%d): ", t;
    printf {p in PEOPLE}: "   %d", x[p,t];
    printf "\n";
}

printf "\nPairings\n";
for {t in TABLES} : {
    printf "Table %d : ",t;
    printf {(p,q) in PAIRS : y[p,q] = 1 && x[p,t] = 1}: " (%2d,%2d) ",p,q;
    printf "\n";
}

end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTSPTW" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="tsptw" class="modal-body modal-body-example">
/* # Traveling Salesman Problem with Time Windows */

param start symbolic;
param finish symbolic, != start;
param maxspeed > 0;
param minspeed > 0, &lt;= maxspeed;

set PLACES;
param lat{PLACES};
param lng{PLACES};
param S1{PLACES};
param S2{p in PLACES} >= S1[p];

# compute great circle distances and minimum travel times
param d2r := 3.1415926/180;
param alpha{a in PLACES, b in PLACES} := sin(d2r*(lat[a]-lat[b])/2)**2 
        + cos(d2r*lat[a])*cos(d2r*lat[b])*sin(d2r*(lng[a]-lng[b])/2)**2;
param gcdist{a in PLACES, b in PLACES} := 2*6371*atan(sqrt(alpha[a,b]),sqrt(1-alpha[a,b]));

# Path constraints
var x{PLACES, PLACES} binary;

# must leave from all nodes except the finish node
s.t. lv1 {a in PLACES : a != finish}: sum{b in PLACES} x[a,b] = 1;
s.t. lv2 : sum{b in PLACES} x[finish,b] = 0;

# must arrive at all places except the start node
s.t. ar1 {a in PLACES : a != start}: sum{b in PLACES} x[b,a] = 1;
s.t. ar2 : sum{b in PLACES} x[b,start] = 0;

# subtour elimination using an idea from Andrew O. Makhorin
var y{PLACES, PLACES} >= 0, integer;
s.t. capbnd {a in PLACES, b in PLACES} : y[a,b] &lt;= (card(PLACES)-1)*x[a,b];
s.t. capcon {a in PLACES} : sum{b in PLACES} y[b,a] 
            + (if a=start then card(PLACES)) = 1 + sum{b in PLACES} y[a,b];

# Time Constraints
param bigM := 50;
var tar{PLACES};         # arrival
var tlv{PLACES};         # departure
var tea{PLACES} >= 0;    # early arrival (arrival before the designated time window)
var tla{PLACES} >= 0;    # late arrival (arrival after the designated time window)
var ted{PLACES} >= 0;    # early departure (departure before the designated time window)
var tld{PLACES} >= 0;    # late departure (departure after the designated time window)

s.t. t0 {a in PLACES} : tlv[a] >= tar[a]; 
s.t. t1 {a in PLACES, b in PLACES} : 
        tar[b] >= tlv[a] + gcdist[a,b]/maxspeed - bigM*(1-x[a,b]);
s.t. t2 {a in PLACES, b in PLACES} : 
        tar[b] &lt;= tlv[a] + gcdist[a,b]/minspeed + bigM*(1-x[a,b]);
s.t. t3 {a in PLACES : a != start } : tea[a] >= S1[a] - tar[a];   # early arrival
s.t. t4 {a in PLACES : a != start } : tla[a] >= tar[a] - S2[a];   # late arrival
s.t. t5 {a in PLACES : a != finish} : ted[a] >= S1[a] - tlv[a];   # early departure
s.t. t6 {a in PLACES : a != finish} : tld[a] >= tlv[a] - S2[a];   # late departure

# the objective is weighted sum of average and maximum time window excursions
var tmax >= 0;
s.t. o1 {a in PLACES} : tea[a] &lt;= tmax;
s.t. o2 {a in PLACES} : tla[a] &lt;= tmax;
s.t. o3 {a in PLACES} : ted[a] &lt;= tmax;
s.t. o4 {a in PLACES} : tld[a] &lt;= tmax;

minimize obj: sum{a in PLACES} (1*tea[a] + 2*tla[a] + 2*ted[a] + 1*tld[a]) + 2*tmax;

solve;

printf "%6s  %3s   %6s  %3s %6s %6s %6s %6s %7s %5s %6s\n", 
    'Depart','','Arrive','','EDep','LDep','EArr','LArr','Dist','Time','Speed';

for {k in card(PLACES)-1..0 by -1} {
    printf {a in PLACES, b in PLACES : (y[a,b]=k) && (x[a,b]=1)}
        "%-3s %7.2f   %-3s %7.2f %6.2f%1s %5.2f%1s %5.2f%1s %5.2f%1s %6.1f %5.2f %6.1f\n", 
        a, tlv[a], b, tar[b], 
        ted[a], if (ted[a]>0) then '*' else ' ',
        tld[a], if (tld[a]>0) then '*' else ' ',
        tea[b], if (tea[b]>0) then '*' else ' ',
        tla[b], if (tla[b]>0) then '*' else ' ',
        gcdist[a,b], (tar[b]-tlv[a]), gcdist[a,b]/(tar[b]-tlv[a]);
}

data;

param start := 'ATL';
param finish := 'ORD';
param maxspeed := 800;
param minspeed := 600;

param : PLACES :         lat            lng       S1       S2 :=
        ATL       33.6366995    -84.4278639      8.0     24.0
        BOS       42.3629722    -71.0064167      8.0      9.0
        DEN       39.8616667   -104.6731667     12.0     15.0
        DFW       32.8968281    -97.0379958     12.0     13.0
        JFK       40.6397511    -73.7789256     18.0     20.0
        LAX       33.9424955   -118.4080684     12.0     16.0
        ORD       41.9816486    -87.9066714     20.0     24.0
        STL       38.7486972    -90.3700289     11.0     13.0
; 

end;
                    

                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleVRP" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="vrp" class="modal-body modal-body-example"><br> /* # Vehicle Routing Problem
/* # Vehicle Routing Problem

A set of airplanes are initially distributed among a set of
starting locations. They are to be assigned routes to collectively
visit a specified set of customers then return the the planes to
designated finishing locations. The optimization objective is to
minimize the total great circle distance.

The data consists of a set of locations with latitude and longitude
information, a list of customers and their respective locations, and
a set of aircraft and their starting and finishing locations. The
aircraft must start and finish at different locations (if needed,
dummy locations with the same latitude and longitude can be 
included in the list of locations).
*/

# Jeffrey Kantor
# March, 2013

# DATA SETS (IN THE DATA SECTION)

# CUSTOMERS is a set of (name,location) pairs 
set CUSTOMERS dimen 2;

# PLANES is a set of (name, start_location, finish_location) triples
set PLANES dimen 3;

# set of locations
set LOCATIONS;
param lat{LOCATIONS};
param lng{LOCATIONS};

# DATA PREPROCESSING

# create a set of planes
set P := setof {(p,sLoc,fLoc) in PLANES} p;

# create a set of all nodes as (name, location) pairs
set START := setof {(p,sLoc,fLoc) in PLANES} (p,sLoc);
set FINISH := setof {(p,sLoc,fLoc) in PLANES} (p,fLoc);
set N := CUSTOMERS union (START union FINISH);

# compute great circle distances [km] between locations from latitude,
# longitude data using Haversine formula
param d2r := 3.1415926/180;
param alpha{a in LOCATIONS, b in LOCATIONS} := sin(d2r*(lat[a]-lat[b])/2)**2 
    + cos(d2r*lat[a])*cos(d2r*lat[b])*sin(d2r*(lng[a]-lng[b])/2)**2;
param gcdist{a in LOCATIONS, b in LOCATIONS} := 
    2*6371*atan( sqrt(alpha[a,b]), sqrt(1-alpha[a,b]) );

# DECISION VARIABLES

# x[p,a,aLoc,b,bLoc] = 1 if plane p flies from (a,aLoc) to (b,bLoc)
var x{P, N, N} binary;

# START AND FINISH CONSTRAINTS

# no planes arrive at the start nodes
s.t. sf1 {p in P, (a,aLoc) in  N, (b,bLoc) in START} : x[p,a,aLoc,b,bLoc] = 0;

# no planes leave the finish nodes
s.t. sf2 {p in P, (a,aLoc) in FINISH, (b,bLoc) in N} : x[p,a,aLoc,b,bLoc] = 0;

# planes must leave from their own start nodes
s.t. sf3 {p in P, (a,aLoc) in START, (b,bLoc) in N : p != a} : x[p,a,aLoc,b,bLoc] = 0;

# planes must return to their own finish nodes
s.t. sf4 {p in P, (a,aLoc) in N, (b,bLoc) in FINISH : p != b} : x[p,a,aLoc,b,bLoc] = 0;

# NETWORK CONSTRAINTS

# one plane arrives at each customer and finish node
s.t. nw1 {(b,bLoc) in (CUSTOMERS union FINISH)} : 
        sum {p in P, (a,aLoc) in (CUSTOMERS union START)} x[p,a,aLoc,b,bLoc] = 1;

# one plane leaves each start and customer node
s.t. nw2 {(a,aLoc) in (START union CUSTOMERS)} :
        sum {p in P, (b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc] = 1;

# planes entering a customer node must leave the same node
s.t. nw3 {p in P, (a,aLoc) in CUSTOMERS} : 
    sum {(b,bLoc) in (CUSTOMERS union START)} x[p,b,bLoc,a,aLoc]
        = sum {(b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc];

# no self loops
s.t. nw4 {p in P, (a,aLoc) in N, (b,bLoc) in N : (a=b) && (aLoc=bLoc)} :
    x[p,a,aLoc,b,bLoc] = 0;

# SUBTOUR ELIMINATION CONSTRAINTS

var y{P,N,N} integer, >= 0;

# route capacity
s.t. sb1 {p in P, (a,aLoc) in N, (b,bLoc) in N} : 
    y[p,a,aLoc,b,bLoc] &lt;= card(CUSTOMERS)*x[p,a,aLoc,b,bLoc];

# allocate tokens to links from the start nodes
s.t. sb2 : sum {p in P, (a,aLoc) in START, (b,bLoc) in N } y[p,a,aLoc,b,bLoc] 
                = card(CUSTOMERS);

# decrease tokens for each step on a path
s.t. sb3 {(a,aLoc) in CUSTOMERS} : 
    sum{p in P, (b,bLoc) in (CUSTOMERS union START)} y[p,b,bLoc,a,aLoc] 
        = 1 + sum{p in P, (b,bLoc) in (CUSTOMERS union FINISH)} y[p,a,aLoc,b,bLoc];

# OBJECTIVE

# route distance for each plane
var routeDistance{P} >= 0;
s.t. ob1 {p in P} : routeDistance[p] 
        = sum{(a,aLoc) in N, (b,bLoc) in N} gcdist[aLoc,bLoc]*x[p,a,aLoc,b,bLoc];

# number of legs on the route for each plane
var routeLegs{P} >= 0;
s.t. ob2 {p in P} : routeLegs[p] = sum{(a,aLoc) in START, (b,bLoc) in N} y[p,a,aLoc,b,bLoc];

# maximum distance on the route of any plane
var maxDistance >= 0;
s.t. ob3 {p in P} : routeDistance[p] &lt;= maxDistance;

# maximum number of legs on the route of any plane
var maxLegs >= 0;
s.t. ob4 {p in P} : routeLegs[p] &lt;= maxLegs;

# pick an objective. Here we minimize total route distance.
minimize distance : sum{p in P} routeDistance[p];

solve;

# OUTPUT POST-PROCESSING

for {p in P} {
    printf "\nRouting for %s\n-------------------\n", p;
    printf "%-20s  %-20s  %10s   \n", 'Depart','Arrive','Dist.';
    for {k in routeLegs[p]..0 by -1} {
        printf {(a,aLoc) in N, (b,bLoc) in N : 
            (x[p,a,aLoc,b,bLoc] = 1) && (y[p,a,aLoc,b,bLoc]=k)} 
            "%-12s  %-5s   %-12s  %-5s   %10.1f km\n",a,aLoc,b,bLoc,gcdist[aLoc,bLoc];
    }
    printf "%42s  %13s\n", '', '---------';
    printf "%42s  %10.1f km\n\n", 'GC Distance Traveled:', routeDistance[p];
}

# DATA SECTION

data;

set CUSTOMERS := 
        ( 'Atlanta',     ATL )
        ( 'Boston',      BOS )
        ( 'Denver',      DEN )
        ( 'Dallas',      DFW )
        ( 'New York',    JFK )
        ( 'Los Angeles', LAX )
        ( 'Chicago',     ORD )
        ( 'St. Louis',   STL ) 
;

set PLANES :=
        ( 'Plane 1', ORD, ORD_)  # use a duplicate location to return place to ORD
        ( 'Plane 2', DFW, DRW_)  # use a duplicate location to return plane to DFW
;

param : LOCATIONS : lat           lng :=
        ATL   33.6366995   -84.4278639
        BOS   42.3629722   -71.0064167
        DEN   39.8616667  -104.6731667
        DFW   32.8968281   -97.0379958
        DRW_  32.8968281   -97.0379958  # duplicate PLANES
        JFK   40.6397511   -73.7789256
        LAX   33.9424955  -118.4080684
        ORD   41.9816486   -87.9066714
        ORD_  41.9816486   -87.9066714  # duplicate PLANES
        STL   38.7486972   -90.3700289
; 

end;
                   
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleVRPTW" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="vrptw" class="modal-body modal-body-example">
/* # Vehicle Routing Problem with Time Windows

 A set of airplanes are initially distributed among a set of
 starting locations. They are to be assigned routes to collectively
 visit a specified set of customers then return the the planes to
 designated finishing locations within designated time windows.

 The data consists of a set of locations with latitude and longitude
 information, a list of customers and their respective locations, and
 a set of aircraft and their starting and finishing locations, and 
 the start and of associated time windows. The aircraft must start 
 and finish at different locations (if needed, dummy locations with
 the same latitude and longitude can be included in the list of 
 locations). Plane speed is constrained to between upper and lower
 bounds.

 The time windows are implemented as 'soft' constraints. Additional
 decision variables are

   * tar[name,loc]  arrival time at (name,loc) 
   * tlv[name,loc]  departure time from (name,loc)
   * tea[name,loc] >= 0  for arrival before the time window
   * tla[name,loc] >= 0  for arrival after the time window
   * ted[name,loc] >= 0  for departure before the time window
   * tld[name,loc] >= 0  for departure after the time window

  A weighted some of tea, tla, ted, and tld constitutes a time 
  penalty which is zero if there is a feasible solution.

  The objective function is weighted sum of the time penalty and
  total route distance.

 Jeffrey Kantor
 March, 2013
*/

# DATA SETS (TO BE GIVEN IN THE DATA SECTION)

param maxspeed > 0;
param minspeed > 0, &lt;= maxspeed;

# CUSTOMERS is a set of (name,location) pairs 
set CUSTOMERS dimen 2;
param T1{CUSTOMERS};
param T2{(name,loc) in CUSTOMERS} >= T1[name,loc];

# PLANES is a set of (name, start_location, finish_location) triples
set PLANES dimen 3;
param S1{PLANES};
param S2{(p,sLoc,fLoc) in PLANES} >= S1[p,sLoc,fLoc];
param F1{PLANES};
param F2{(p,sLoc,fLoc) in PLANES} >= F1[p,sLoc,fLoc];

# set of locations
set LOCATIONS;
param lat{LOCATIONS};
param lng{LOCATIONS};

# DATA PREPROCESSING

# set of planes
set P := setof {(p,sLoc,fLoc) in PLANES} p;

# compute START as (plane,startlocation) pairs with time windows
set START := setof {(p,sLoc,fLoc) in PLANES} (p,sLoc);
param TS1{(p,sLoc) in START} := 
    max{ (q,tLoc,fLoc) in PLANES : (p=q) && (sLoc=tLoc) } S1[p,sLoc,fLoc];
param TS2{(p,sLoc) in START} := 
    min{ (q,tLoc,fLoc) in PLANES : (p=q) && (sLoc=tLoc) } S2[p,sLoc,fLoc];

# compute FINISH as (plane,finishlocation) pairs with  time windows
set FINISH := setof {(p,sLoc,fLoc) in PLANES} (p,fLoc);
param TF1{(p,fLoc) in FINISH} := 
    max{ (q,sLoc,gLoc) in PLANES : (p=q) && (fLoc=gLoc) } F1[p,sLoc,fLoc];
param TF2{(p,fLoc) in FINISH} := 
    min{ (q,sLoc,gLoc) in PLANES : (p=q) && (fLoc=gLoc) } F2[p,sLoc,fLoc];

# create a complete of nodes as (name, location) pairs
set N := CUSTOMERS union (START union FINISH);

# great circle distances between locations
param d2r := 3.1415926/180;
param alpha{a in LOCATIONS, b in LOCATIONS} := sin(d2r*(lat[a]-lat[b])/2)**2 
    + cos(d2r*lat[a])*cos(d2r*lat[b])*sin(d2r*(lng[a]-lng[b])/2)**2;
param gcdist{a in LOCATIONS, b in LOCATIONS} := 
    2*6371*atan( sqrt(alpha[a,b]), sqrt(1-alpha[a,b]) );

# DECISION VARIABLES

# x[p,a,aLoc,b,bLoc] = 1 if plane p flies from (a,aLoc) to (b,bLoc)
var x{P, N, N} binary;

# START AND FINISH CONSTRAINTS

# no planes arrive at the start nodes
s.t. sf1 {p in P, (a,aLoc) in  N, (b,bLoc) in START} : 
        x[p,a,aLoc,b,bLoc] = 0;

# no planes leave the finish nodes
s.t. sf2 {p in P, (a,aLoc) in FINISH, (b,bLoc) in N} : 
        x[p,a,aLoc,b,bLoc] = 0;

# planes must leave from their own start nodes
s.t. sf3 {p in P, (a,aLoc) in START, (b,bLoc) in N : p != a} : 
        x[p,a,aLoc,b,bLoc] = 0;

# planes must return to their own finish nodes
s.t. sf4 {p in P, (a,aLoc) in N, (b,bLoc) in FINISH : p != b} : 
        x[p,a,aLoc,b,bLoc] = 0;

# NETWORK CONSTRAINTS

# one plane arrives at each customer and finish node
s.t. nw1 {(b,bLoc) in (CUSTOMERS union FINISH)} : 
        sum {p in P, (a,aLoc) in (CUSTOMERS union START)} x[p,a,aLoc,b,bLoc] = 1;

# one plane leaves each start and customer node
s.t. nw2 {(a,aLoc) in (START union CUSTOMERS)} :
        sum {p in P, (b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc] = 1;

# planes entering a customer node must leave the same node
s.t. nw3 {p in P, (a,aLoc) in CUSTOMERS} : 
    sum {(b,bLoc) in (CUSTOMERS union START)} x[p,b,bLoc,a,aLoc]
        = sum {(b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc];

# no self loops
s.t. nw4 {p in P, (a,aLoc) in N, (b,bLoc) in N : (a=b) && (aLoc=bLoc)} :
    x[p,a,aLoc,b,bLoc] = 0;

# SUBTOUR ELIMINATION CONSTRAINTS

var y{P,N,N} >= 0;

# route capacity
s.t. sb1 {p in P, (a,aLoc) in N, (b,bLoc) in N} : 
    y[p,a,aLoc,b,bLoc] &lt;= card(CUSTOMERS)*x[p,a,aLoc,b,bLoc];

# allocate tokens to links from the start nodes
s.t. sb2 : sum {p in P, (a,aLoc) in START, (b,bLoc) in N } y[p,a,aLoc,b,bLoc] 
               = card(CUSTOMERS);

# decrease tokens for each step on a path
s.t. sb3 {(a,aLoc) in CUSTOMERS} : 
    sum{p in P, (b,bLoc) in (CUSTOMERS union START)} y[p,b,bLoc,a,aLoc] 
        = 1 + sum{p in P, (b,bLoc) in (CUSTOMERS union FINISH)} y[p,a,aLoc,b,bLoc];

# TIME WINDOW CONSTRAINTS
param bigM := 50;
var tar{N};
var tlv{N};
var tea{N} >= 0;
var tla{N} >= 0;
var ted{N} >= 0;
var tld{N} >= 0;

s.t. t00 {(a,aLoc) in N} : tlv[a,aLoc] >= tar[a,aLoc];
s.t. t01 {p in P, (a,aLoc) in N, (b,bLoc) in N} : tar[b,bLoc] >= tlv[a,aLoc] 
        + gcdist[aLoc,bLoc]/maxspeed - bigM*(1-x[p,a,aLoc,b,bLoc]);
s.t. t02 {p in P, (a,aLoc) in N, (b,bLoc) in N} : tar[b,bLoc] &lt;= tlv[a,aLoc] 
        + gcdist[aLoc,bLoc]/minspeed + bigM*(1-x[p,a,aLoc,b,bLoc]);
s.t. t03 {(a,aLoc) in CUSTOMERS} : tea[a,aLoc] >= T1[a,aLoc] - tar[a,aLoc];
s.t. t04 {(a,aLoc) in FINISH} :    tea[a,aLoc] >= TF1[a,aLoc] - tar[a,aLoc];
s.t. t05 {(a,aLoc) in CUSTOMERS} : tla[a,aLoc] >= tar[a,aLoc] - T2[a,aLoc];
s.t. t06 {(a,aLoc) in FINISH} :    tla[a,aLoc] >= tar[a,aLoc] - TF2[a,aLoc];
s.t. t07 {(a,aLoc) in START} :     ted[a,aLoc] >= TS1[a,aLoc] - tlv[a,aLoc];
s.t. t08 {(a,aLoc) in CUSTOMERS} : ted[a,aLoc] >= T1[a,aLoc] - tlv[a,aLoc];
s.t. t09 {(a,aLoc) in START} :     tld[a,aLoc] >= tlv[a,aLoc] - TS2[a,aLoc];
s.t. t10 {(a,aLoc) in CUSTOMERS} : tld[a,aLoc] >= tlv[a,aLoc] - T2[a,aLoc];

# OBJECTIVE
# The objective function is a weighted sum of violations of the time window
# constraints and the total distance traveled. 

var routeDistance{P} >= 0;
s.t. ob1 {p in P} : routeDistance[p] 
        = sum{(a,aLoc) in N, (b,bLoc) in N} gcdist[aLoc,bLoc]*x[p,a,aLoc,b,bLoc];

var totalDistance >= 0;
s.t. ob2 : totalDistance = sum{p in P} routeDistance[p];

var timePenalty >= 0;
s.t. ob3 : timePenalty = 
    sum{(a,aLoc) in N} (tea[a,aLoc] + 2*tla[a,aLoc] + 2*ted[a,aLoc] + tld[a,aLoc]);

minimize obj: 5*timePenalty + totalDistance/maxspeed;

solve;

# OUTPUT POST-PROCESSING

param routeTime{p in P} := 
    sum{(a,aLoc) in N, (b,bLoc) in N} (tar[b,bLoc]-tlv[a,aLoc])*x[p,a,aLoc,b,bLoc];

param routeLegs{p in P} :=
    sum{(a,aLoc) in START, (b,bLoc) in N} y[p,a,aLoc,b,bLoc];

for {p in P} {
    printf "\nRouting for %s\n-------------------\n", p;
    printf "%-24s  %-24s  %7s %5s %6s \n", 
        'Depart','Arrive','Dist.','Time','Speed';
    for {k in routeLegs[p]..0 by -1} {
        printf {(a,aLoc) in N, (b,bLoc) in N : 
            (x[p,a,aLoc,b,bLoc] = 1) && (abs(y[p,a,aLoc,b,bLoc]-k)&lt;0.001)} 
            "%-12s %-4s %5.2f%1s  %-12s %-4s %5.2f%1s  %7.1f %5.2f %6.1f\n",
            a, aLoc, tlv[a,aLoc], 
            if (ted[a,aLoc] > 0) then "E" else (if (tld[a,aLoc] > 0) then "L" else " "),
            b, bLoc, tar[b,bLoc],
            if (tea[b,bLoc] > 0) then "E" else (if (tla[b,bLoc] > 0) then "L" else " "),
            gcdist[aLoc,bLoc], tar[b,bLoc]-tlv[a,aLoc], 
            if (gcdist[aLoc,bLoc] > 0) then gcdist[aLoc,bLoc]/(tar[b,bLoc]-tlv[a,aLoc]) else 0;
    }
    printf "%50s  %7s %5s\n", '', '-------','-----';
    printf "%50s  %7.1f %5.2f\n\n", 'Totals:', routeDistance[p], routeTime[p];
}

# DATA SECTION

data;

param maxspeed := 800;
param minspeed := 600;

param : CUSTOMERS :            T1      T2 := 
        'Atlanta'      ATL     8.0    24.0
        'Boston'       BOS     8.0     9.0
        'Denver'       DEN    12.0    15.0
        'Dallas'       DFW    12.0    13.0
        'New York'     JFK    18.0    20.0
        'Los Angeles'  LAX    12.0    16.0
        'Chicago'      ORD    20.0    24.0
        'St. Louis'    STL    11.0    13.0
;

param : PLANES :                     S1     S2     F1     F2 :=
        'Plane 1'    ORD    ORD_    8.0   24.0    8.0   24.0
        'Plane 2'    DFW    DRW_    8.0   24.0    8.0   24.0
;

param : LOCATIONS : lat           lng :=
        ATL   33.6366995   -84.4278639
        BOS   42.3629722   -71.0064167
        DEN   39.8616667  -104.6731667
        DFW   32.8968281   -97.0379958  # start location
        DRW_  32.8968281   -97.0379958  # finish location
        JFK   40.6397511   -73.7789256
        LAX   33.9424955  -118.4080684
        ORD   41.9816486   -87.9066714  # start location
        ORD_  41.9816486   -87.9066714  # finish location
        STL   38.7486972   -90.3700289
; 

end;


                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTheNewsvendorProblem" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="theNewsvendorProblem" class="modal-body modal-body-example">
                   /* # The Newsvendor Problem

The newsvendor problem is a two stage decision problem with recourse. The 
    vendor needs to decide how much inventory to order today to fulfill an 
    uncertain demand. The data includes the unit cost, price, and salvage value of 
    the product being sold, and a probabilistic forecast of demand. The objective 
    is to maximize expected profit.

As shown in lecture, this problem can be solved with a plot, and the solution
    interpreted in terms of a cumulative probability distribution. The advantage
    of a MathProg model is that additional constraints or other criteria may be 
    considered, such as risk aversion.

There is an extensive literature on the newsvendor problem which has been 
    studied since at least 1888. See 
    <a rel="external" href="http://www.isye.umn.edu/courses/ie5551/additional%20materials/newsvendort.pdf">here</a> for a thorough discussion.
*/

/* Unit Price Data */
param r >= 0;                              # Price
param c >= 0;                              # Cost
param w >= 0;                              # Salvage value

/* Price data makes sense only if  Price > Cost > Salvage */
check: c &lt;= r;
check: w &lt;= c;

/* Probabilistic Demand Forecast */
set SCENS;                                 # Scenarios
param D{SCENS} >= 0;                       # Demand
param Pr{SCENS} >= 0;                      # Probability

/* Probabilities must sum to one. */
check: sum{k in SCENS} Pr[k] = 1;

/* Expected Demand */
param ExD := sum{k in SCENS} Pr[k]*D[k];

/* Lower Bound on Profit: Expected Value of the Mean Solution */
param EVM := -c*ExD + sum{k in SCENS} Pr[k]*(r*min(ExD,D[k])+w*max(ExD-D[k],0));

/* Upper Bound on Profit: Expected Value with Perfect Information */
param EVPI := sum{k in SCENS} Pr[k]*(r-c)*D[k];

/* Two Stage Stochastic Programming */
var x >= 0;                     # Stage 1 (Here and Now): Order Quqntity
var y{SCENS}>= 0;               # Stage 2 (Scenario Dep): Actual Sales
var ExProfit;                   # Expected Profit

/* Maximize Expected Profit */
maximize OBJ: ExProfit;

/* Goods sold are limited by the order quantities and the demand  */
s.t. PRFT: ExProfit = -c*x + sum{k in SCENS} Pr[k]*(r*y[k] + w*(x-y[k]));
s.t. SUPL {k in SCENS}: y[k] &lt;= x;
s.t. DMND {k in SCENS}: y[k] &lt;= D[k];

solve;

table Table_EVM {k in SCENS} OUT "JSON" "Expected Value for the Mean Scenario" "Table":
   k~Scenario,
   Pr[k]~Probability, 
   D[k]~Demand, 
   ExD~Order, 
   min(ExD,D[k])~Sold,
   max(ExD-D[k],0)~Salvage, 
   -c*ExD + r*min(ExD,D[k]) + w*max(ExD-D[k],0)~Profit;
   
table Table_EVPI {k in SCENS} OUT "JSON" "Expected Value of Perfect Information" "Table":
   k~Scenario,
   Pr[k]~Probability, 
   D[k]~Demand, 
   D[k]~Order, 
   D[k]~Sold,
   0~Salvage, 
   -c*D[k] + r*D[k]~Profit;
   
table Table_SP {k in SCENS} OUT "JSON" "Expected Value by Stochastic Programming" "Table":
   k~Scenario,
   Pr[k]~Probability, 
   D[k]~Demand, 
   x~Order, 
   y[k]~Sold,
   x-y[k]~Salvage, 
   -c*x + r*y[k] + w*(x-y[k])~Profit;
   
table Summary {k in 1..1} OUT "JSON" "Summary" "Table":
   EVPI-ExProfit~Value_of_Perfect_Information,
   ExProfit - EVM~Value_of_Stochastic_Solution; 

printf "EXPECTED VALUE OF THE MEAN SOLUTION\n" >> "EVM";
printf "\nSCENARIO     PROB   DEMAND    ORDER     SOLD  SALVAGE   PROFIT\n" >> "EVM";
printf {k in SCENS} "%s     %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f\n",
   k, Pr[k], D[k], ExD, min(ExD,D[k]), max(ExD-D[k],0), 
   -c*ExD + r*min(ExD,D[k]) + w*max(ExD-D[k],0) >> "EVM";
printf "\n%s               %7.2f  %7.2f  %7.2f  %7.2f  %7.2f\n",
   'MEAN', ExD, ExD, sum{k in SCENS}Pr[k]*min(ExD,D[k]),
   sum{k in SCENS}Pr[k]*max(ExD-D[k],0),EVM >> "EVM";

printf "EXPECTED VALUE WITH PERFECT INFORMATION\n" >> "EVPI";
printf "\nSCENARIO     PROB   DEMAND    ORDER     SOLD  SALVAGE   PROFIT\n" >> "EVPI";
printf {k in SCENS} "%s     %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f\n",
   k, Pr[k], D[k], D[k], D[k], 0, -c*D[k] + r*D[k] >> "EVPI";
printf "\n%s               %7.2f  %7.2f  %7.2f  %7.2f  %7.2f\n",
   'MEAN', ExD, ExD, ExD,0,EVPI >> "EVPI";

printf "TWO STAGE STOCHASTIC PROGRAMMING\n\n" >> "SP";
printf " Order Quantity = %g\n", x >> "SP";
printf "Expected Profit = %g\n", ExProfit >> "SP";
printf "\nSCENARIO     PROB   DEMAND    ORDER     SOLD  SALVAGE   PROFIT\n" >> "SP";
printf {k in SCENS} "%s     %7.2f  %7.2f  %7.2f  %7.2f  %7.2f  %7.2f\n",
   k, Pr[k], D[k], x, y[k], x-y[k], -c*x + r*y[k] + w*(x-y[k]) >> "SP";
printf "\n%s               %7.2f  %7.2f  %7.2f  %7.2f  %7.2f\n",
   'MEAN', ExD, x, sum{k in SCENS}Pr[k]*y[k],
   sum{k in SCENS}Pr[k]*(x-y[k]),ExProfit >> "SP";

printf "    VALUE OF PERFECT INFORMATION = %7.2f\n",EVPI-ExProfit >> "Summary";
printf "VALUE OF THE STOCHASTIC SOLUTION = %7.2f\n",ExProfit - EVM >> "Summary"; 

data;

/* Problem Data corresponds to a hypothetical case of selling programs prior 
to a home football game. */

param r := 10.00;                         # Unit Price
param c :=  6.00;                         # Unit Cost
param w :=  2.00;                         # Unit Salvage Value

param: SCENS:  Pr    D   :=
       HiDmd   0.25  250
       MiDmd   0.50  125
       LoDmd   0.25   75 ;

end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleBPMACO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="BPMACO" class="modal-body modal-body-example">
                    /* # Binomial Pricing Model for an American Call Option

Determines the price of an American call option using a binomial option
pricing model. The option price is the minimum value of a portfolio
that replicates the option payoff at expiration or at early exercise.
*/

# Asset Model
param S0 := 100;         # initial price   
param r := 0.06;         # mean return (annualized)
param sigma := 0.3;      # volatility (annualized)

# Bond Price
param B0 := 1;           # initial value
param rf := 0.05;        # risk-free interest rate

# Option
param Kstrike := 100;    # strike price
param Tf := 0.5;           # time to expiration (years)

# Construct a recombining binomial tree
param nPeriods := 10;
set PERIODS := {0..nPeriods};
set STATES {p in PERIODS} := {0..p};
param u := exp(sigma*sqrt(Tf/nPeriods));
param d := 1/u;
param pr := (exp(r*Tf/nPeriods)-d)/(u-d);

param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;
param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));

# Replicating Portfolio
var C{p in PERIODS, s in STATES[p]};
var x{p in PERIODS, s in STATES[p]};
var y{p in PERIODS, s in STATES[p]};

portfolio {p in PERIODS, s in STATES[p]}: C[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];

# Self financing constraints
do {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= C[p+1,s];
up {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= C[p+1,s+1];

# Finance early exercise option
edo{p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= S[p+1,s] - Kstrike;
eup{p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= S[p+1,s+1] - Kstrike;
    
# Payoff option value
Payoff {s in STATES[nPeriods]} : C[nPeriods,s] >= max(0, S[nPeriods,s] - Kstrike);

# Objective
minimize OptionPrice : C[0,0];
    
solve;

printf "Option Price Value = %.2f\n", C[0,0];
    
table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :
    p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, C[p,s]~Option;

end;

                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleBPMAPO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="BPMAPO" class="modal-body modal-body-example">
                    /* # Binomial Pricing Model for an American Put Option

Determines the price of an American put option for an asset in which the
price model is a binomial tree. The option price is the minimum value
of a portfolio that replicates the option payoff at expiration, and can
payoff the early exercise of the option. (Data is from Hull, Sec 11.7).
*/

# Asset Model
param S0 := 50;          # initial price   
param r := 0.06;         # mean return (annualized)
param sigma := 0.3;      # volatility (annualized)

# Bond Price
param B0 := 1;           # initial value
param rf := 0.05;        # risk-free interest rate

# Option
param Kstrike := 52;     # strike price
param Tf := 2;           # time to expiration (years)

# Construct a recombining binomial tree
param nPeriods := 2;
set PERIODS := {0..nPeriods};
set STATES {p in PERIODS} := {0..p};
param u := exp(sigma*sqrt(Tf/nPeriods));
param d := 1/u;
param pr := (exp(r*Tf/nPeriods)-d)/(u-d);

param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;
param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));

# Replicating Portfolio
var P{p in PERIODS, s in STATES[p]};
var x{p in PERIODS, s in STATES[p]};
var y{p in PERIODS, s in STATES[p]};

portfolio {p in PERIODS, s in STATES[p]}: P[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];

# Self financing constraints
do {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= P[p+1,s];
up {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= P[p+1,s+1];

# Finance early exercise option
edo{p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= Kstrike - S[p+1,s];
eup{p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= Kstrike - S[p+1,s+1];
    
# Payoff option value
Payoff {s in STATES[nPeriods]} : P[nPeriods,s] >= max(0, Kstrike - S[nPeriods,s]);

# Objective
minimize OptionPrice : P[0,0];
    
solve;

printf "Option Price Value = %.2f\n", P[0,0];
    
table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :
    p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, P[p,s]~Option;

end;

                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleBPMECO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="BPMECO" class="modal-body modal-body-example">
                    /* # Binomial Pricing Model for a European Call Option

Determines the price of a European call option for an asset in which the
price model is a binomial tree. The option price is the minimum value
of a portfolio that replicates the option payoff at expiration.
*/

# Asset Model
param S0 := 100;         # initial price   
param r := 0.06;         # mean return (annualized)
param sigma := 0.3;      # volatility (annualized)

# Bond Price
param B0 := 1;           # initial value
param rf := 0.03;        # risk-free interest rate

# Option
param Kstrike := 110;    # strike price
param Tf := 1;           # time to expiration (years)

# Construct a recombining binomial tree
param nPeriods := 10;
set PERIODS := {0..nPeriods};
set STATES {p in PERIODS} := {0..p};
param u := exp(sigma*sqrt(Tf/nPeriods));
param d := 1/u;
param pr := (exp(r*Tf/nPeriods)-d)/(u-d);

param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;
param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));

# Replicating Portfolio
var C{p in PERIODS, s in STATES[p]};
var x{p in PERIODS, s in STATES[p]};
var y{p in PERIODS, s in STATES[p]};

portfolio {p in PERIODS, s in STATES[p]}: C[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];

# Self financing constraints
do {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= C[p+1,s];
up {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= C[p+1,s+1];
    
# Payoff option value
Payoff {s in STATES[nPeriods]} : C[nPeriods,s] >= max(0, S[nPeriods,s] - Kstrike);

# Objective
minimize OptionPrice : C[0,0];
    
solve;

printf "Option Price Value = %.2f\n", C[0,0];

table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :
    p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, C[p,s]~Option;

end;


                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleBPMEPO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="BPMEPO" class="modal-body modal-body-example">
/* # Binomial Pricing Model for a European Put Option

Determines the price of an European put option for an asset in which the
price model is a binomial tree. The option price is the minimum value
of a portfolio that replicates the option payoff at expiration, and can
payoff the early exercise of the option. (Data is from Hull, Sec 11.7).

*/

# Asset Model
param S0 := 50;          # initial price   
param r := 0.06;         # mean return (annualized)
param sigma := 0.3;      # volatility (annualized)

# Bond Price
param B0 := 1;           # initial value
param rf := 0.05;        # risk-free interest rate

# Option
param Kstrike := 52;     # strike price
param Tf := 2;           # time to expiration (years)

# Construct a recombining binomial tree
param nPeriods := 2;
set PERIODS := {0..nPeriods};
set STATES {p in PERIODS} := {0..p};
param u := exp(sigma*sqrt(Tf/nPeriods));
param d := 1/u;
param pr := (exp(r*Tf/nPeriods)-d)/(u-d);

param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;
param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));

# Replicating Portfolio
var P{p in PERIODS, s in STATES[p]};
var x{p in PERIODS, s in STATES[p]};
var y{p in PERIODS, s in STATES[p]};

portfolio {p in PERIODS, s in STATES[p]}: P[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];

# Self financing constraints
do {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= P[p+1,s];
up {p in PERIODS, s in STATES[p] : p &lt; nPeriods}: 
    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= P[p+1,s+1];
    
# Payoff option value
Payoff {s in STATES[nPeriods]} : P[nPeriods,s] >= max(0, Kstrike - S[nPeriods,s]);

# Objective
minimize OptionPrice : P[0,0];
    
solve;

printf "Option Price Value = %.2f\n", P[0,0];
    
table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :
    p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, P[p,s]~Option;

end;

                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExamplePolitical" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="PoliticalArb" class="modal-body modal-body-example">
                /* # Arbitrage in Political Prediction Markets

 An arbitrage is an opportunity for an investor to allocate money 
 among set of investments such that there is non-negative return for all
 outcomes. This situation is demonstrated below using data collected on
 September 27, 2008 at 10:30am EST for in 2008 US Presidential Election
 prediction markets. The outcomes, which are assumed to exhaust all 
 possibilities, are:
 
      1 The Democratic Party Candidate wins the U.S. Election
      2 The Republican Party Candidate wins the U.S. Election
      
 Prices and payouts are gathered for these outcomes from three markets:

      1 Intrade (Buy price for a $10 pay out) 
      2 IEM (Ask price for $1 pay out)
      3 Betfair (Odds less 5% commission on winnings for a $1 bet)
      
 Prices and payoffs are net of any transaction or trading costs.
*/

# Data
set CONTRACTS dimen 2;
param price{CONTRACTS};
param payout{CONTRACTS};

# Exact markets and events from set of contracts
set MARKETS := setof {(m,e) in CONTRACTS} m;
set EVENTS := setof {(m,e) in CONTRACTS} e;

# The decision variables are the amount invested in each contract.
# The non-negativity condition means no shorting is allowed.
var x{CONTRACTS} >= 0;

# The total investment is limited to $1,000
s.t. investment : sum{(m,e) in CONTRACTS} price[m,e]*x[m,e] &lt;= 1000;

# The objective is maximize the worst-case payout
var minpayout >= 0;
s.t. arbitrage {e in EVENTS} : sum {m in MARKETS} payout[m,e]*x[m,e] >= minpayout;

maximize obj: minpayout;

solve;

printf "Market     Contract           Price  Payout   Units    Cost   Payout\n"
    >> 'Summary for a $1,000 Investment';
printf "------     --------           -----  ------   -----    ----   ------\n"
    >> 'Summary for a $1,000 Investment';
printf {(m,e) in CONTRACTS} 
    "%-10s %-16s  %6.2f  %6.2f  %6.2f  %6.2f %8.2f\n",
    m, e, price[m,e], payout[m,e], x[m,e], price[m,e]*x[m,e], 
    payout[m,e]*x[m,e] >> 'Summary for a $1,000 Investment';
    
table tout {(m,e) in CONTRACTS : x[m,e] > 0} OUT "GCHART" "Arbitrage" "PieChart" : 
    (m&"-"&e)~Contract,
    x[m,e];

data;

param : CONTRACTS :                 price  payout :=
    Intrade    'Democrat Wins'       5.59   10.00
    Intrade    'Republican Wins'     4.30   10.00
    IEM        'Democrat Wins'       0.64    1.00
    IEM        'Republican Wins'     0.36    1.00
    Betfair    'Democrat Wins'       1.00    1.48
    Betfair    'Republican Wins'     1.00    2.95
;

end;
   
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleRiskNeutral" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="RiskNeutral" class="modal-body modal-body-example">
                   /* # Risk Neutral Analysis for _American Idol_

_American Idol_ was a singing competition televised in the United States from 2002 to 
2016 in which the television audience voted for their favorite contestant in the final 
rounds. Each week the contestant with the lowest number of votes was dropped until a 
winner emerged in the final episode. The intense interest in  the singing competition 
attracted the attention of third-party agents who offered an opportunity to bet on the 
eventual winner. Here we analyze a sample of the betting market from Season 12 of the 
show prior to the episode featureing the final nine singers.

## Model for Maximum Risk Free Return

A betting agent will quote the payout for a wager on a particular contestant. Label the 
agent \\(a\\), the contestant \\(c\\), and the amount wagered as \\(P_{c,a}(0)\\) 
(typically $100). Let \\(n_{c,a}\\) denote the number of bets an investor places on 
contestant \\(c\\) with agent \\(a\\). We assume the agents will only accept non-negative 
wagers (i.e., no 'shorting') so that \\(n_{c,x} \geq 0\\). The total cost to the investor 
is
    
\\[w(0)=\sum_{c\in C}\sum_{a\in A}P_{c,a}(0)n_{c,a}\\]

If contestant \\(c\\) eventually wins, the payout quoted by agent \\(a\\) is
\\(P_{c,a}(1)\\), otherwise the payout is zero. If contestant \\(c\\) wins then the 
payoff from all agents is

\\[\sum_{a \in A} P_{c,a}(1) n_{c,a}\\]

A risk neutral investor seeks a betting strategy offering a risk-free regardless of which 
contestant wins. For every contestant

\\[\sum_{a\in A} P_{c,a}(1)n_{c,a} > (1+r_f)w(0) \qquad \forall c\in C \\]

where \\(r_f\\) is the risk-free return. After substitution

\\[\sum_{a\in A} P_{c,a}(1)n_{c,a} > (1+r_f)\sum_{c\in C}\sum_{a\in A}P_{c,a}(0)n_{c,a} 
  \qquad \forall c\in C \\]

The notation is simplified by introducing a variable \\(x_{c,a} = P_{c,a}(0)n_{c,a}\\) 
equal to the value of the wager placed on contestant \\(c\\) with agent \\(a\\). Then  
defining the total relative return for a wager on contestant \\(c\\).

\\[p_{c,a} = \frac{P_{c,a}(1)}{P_{c,a}(0)}\\]

leaves an inequality for each contestant that reads

\\[\sum_{a \in A} p_{c,a} x_{c,a} - (1 + r_f)\sum_{c\in C}\sum_{a\in A} x_{c,a} > 0 
  \qquad \forall c\in C\\]
   
At this stage we have a set of linear inequalities in the non-negative variables \\
(x_{c,a}\\). Given data on payoffs, the total amount of money to wager, and a risk-free 
rate \\(r_f\\), we can try to compute a solution that provides a return higher than the 
risk-free rate. If such a solution exists then there exists an arbitrage opportunity.

## Farka's Lemma

Arbitrages, however, are rare. When they arise it is likely investors will exploit the 
situation thereby driving the market back to a new price/demand equilibrium. So rather 
than seek solutions to a problem where a solution isn't likely to exist, we change the 
formulation using a version of Farka's lemma. 

Consider two sets of linear inequalities, the first written

\\[A \gg 0\\]
\\[x \geq 0 \\]

where the matrix/vector notation \\(A \gg 0\\) means a strict inequality between 
corresponding elements of vector quantities, and the second written as

\\[ A^Ty \leq 0 \\]
\\[ y \geq 0\\]

Farka's lemma states that one or the other of these two sets has a feasible solution, but 
not both. Applying this result, an arbitrage does not exist if there are variables 
\\(y_c \geq 0\\) such that

\\[p_{c,a}y_c - (1 + r_f)\sum_{c \in C}y_c \leq 0 \qquad \forall a \in A, \forall c \in C\\]

## Solution for Maximum Risk-Free Return

It's easy to see that if \\(r_f\\) is large enough, then an aribitrage can't exist.  The
smallest value for which an arbitrage does not exist (therefore an upper bound on the
attainable risk-free return obtained by any betting strategy) is given by 

\\[\min_{y_c \geq 0} r_f\\]

subject to

\\[p_{c,a}y_c \leq  (1 + r_f) \qquad \forall a \in A, \forall c \in C\\]
\\[\sum_{c \in C}y_c = 1\\]

The parameters \\(y_c\\) can be interpreted as a risk-neutral probability for 
contestant \\(c\\) to win the competition. The actual order of finish is listed
below for contestants in Season 12 of _American Idol_, so you can see how well this
works.
*/

set AGENTS;
set CONTESTANTS;
param payout{CONTESTANTS,AGENTS};
param finish{CONTESTANTS};

var x{CONTESTANTS,AGENTS} >= 0;
var y{CONTESTANTS} >= 0;
var rf;

s.t. total: sum{c in CONTESTANTS, a in AGENTS} x[c,a] = 1;
s.t. return {c in CONTESTANTS} : sum{a in AGENTS} payout[c,a]*x[c,a] >= 100*(1 + rf);

s.t. prob : sum{c in CONTESTANTS} y[c] = 1;
s.t. noarb {c in CONTESTANTS, a in AGENTS} : (1+rf)*100 >= payout[c,a]*y[c];

minimize obj: rf;

solve;

printf "Maximum risk-free return = %7.4f\n\n", rf;

printf "%15s      %6s", "CONTESTANT", "y[c]";
printf {a in AGENTS} : "%14s", a;
printf "\n";

for {c in CONTESTANTS} {
	printf "%15s(%1d)   %6.3f",c, finish[c], y[c];
	printf {a in AGENTS} : "        %6.2f", 100*x[c,a];
    printf "\n";
}
printf "%15s      %6s", "TOTALS", " ";
for {a in AGENTS} : printf "        %6.2f", sum{c in CONTESTANTS} 100*x[c,a];
data;

set AGENTS := 
Diamond  
SportsBetting
Bovada
;

param : CONTESTANTS : finish := 
'Candice Glover'    1
'Angela Miller'     3
'Kree Harrison'     2
'Amber Holcomb'     4
'Janelle Arthur'    5
'Lazaro Arbos'      6
'Burnell Taylor'    7
'Devin Velez'       8
'Paul Jolley'       9
;

param payout :   Diamond  SportsBetting  Bovada :=
'Candice Glover'     115      190      200
'Angela Miller'      125      180      225
'Kree Harrison'      230      180      275
'Janelle Arthur'    1100     1150     1200
'Lazaro Arbos'      1100      950     1400
'Amber Holcomb'     1100      800     1200
'Paul Jolley'       2800     4000     3300
'Burnell Taylor'    2100     2500     2500
'Devin Velez'       2600     3500     3300
;

end;

                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleSavingRetirement" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content">
                <div id="retirement" class="modal-body modal-body-example">
                   /* # Saving for Retirement

Retirement savings is an often neglected priority in personal finance. This model
        demonstrates the computation of a simple savings plan over a professional career
        that accommodates several major expenditures in addition to meeting a savings target
        equal to eight times salary at retirement.

The model assumes a constant
        rate of inflation <span class="math">\(r_f\)</span>, a constant rate of
        return on investments <span class="math">\(r_i\)</span>, and a salary model
        <span class="math">\[S_k = \frac{(1+r_f)^k (\alpha + \beta k)}{1 + \beta k}S_{\infty}\]</span>
        where <span class="math">\(k\)</span> denotes year, <span class="math">\(S_{\infty}\)</span>
        the ultimate salary, <span class="math">\(\alpha\)</span> is the starting salary as
        a fraction of the ultimate salary, and <span class="math">\(\beta\)</span> is a
        constant with units of inverse time reflecting the relative speed of career growth.
        Examples of additional expenses is a provision to cover the college tuition expenses
        of several children.

The optimization objective is to determine a bound on the fraction of salary that 
        needs to be saved to meet the projected expenses.

An interesting exercise is to modify the model to include other expenses typical of
        a professional career, such as the purchase of real estate, and the management of
        personal debt. But be careful not to read too much into the results of this type of
        modeling. This model is deterministic while real life is not!
*/

/* Investment Parameters */
param T := 40;                    # time Horizon (years)
param Nper := 1*T;                # total number of periods
param Ri := 0.05;                 # annual investment return
param Rf := 0.03;                 # annual inflation (discount)
param Wi := 0;                    # initial wealth

/* calculated quantities */
set N := 0..Nper;                 # index set
param dT := T/Nper;               # time step
param t{n in N} := n*dT;          # time
param ri := Ri*dT;                # investment return/period
param rf := Rf*dT;                # inflation/period

/* salary model */
param salary{n in N} := (150000*(1+rf)**n)*(0.4+0.1*t[n])/(1+0.1*t[n]);

/* saving decision variables */
var w{N} >= 0;                    # wealth at the start of period n
var u{N} >= 0;                    # savings in period n
var fSave;                        # fraction of salary saved

/* what things are we saving for? */
set EXPENSES := {"TuitionA","TuitionB","TuitionC"};
var x{N,EXPENSES} >=0;

/* retirement goal: savings equal to 8 times salary */
s.t. Retirement: w[Nper] = 8*salary[Nper];

/* tuition: present value of 40000/year for each child */
s.t. TuitionA {n in 18/dT..21/dT}: x[n,"TuitionA"] = 40000*(1+rf)**n;
s.t. TuitionB {n in 20/dT..23/dT}: x[n,"TuitionB"] = 40000*(1+rf)**n;
s.t. TuitionC {n in 22/dT..25/dT}: x[n,"TuitionC"] = 40000*(1+rf)**n;

/* wealth accumulation */
s.t. IC: w[0] = Wi;
s.t. FC {n in 1..Nper}: w[n] = (1+ri)*(w[n-1] + u[n-1]) - sum{e in EXPENSES}x[n,e];

/* Objective: Minimize fraction of the salary that is saved */
s.t. MaxSavings {n in 0..Nper}: u[n] &lt;= fSave*salary[n];

/* minimize present value of the savings plan */
minimize SaveFraction: fSave;

solve;

table tab0 {n in 0..Nper} OUT "JSON" "Projected Wealth" "LineChart": 
    n~Year, w[n]~Wealth;

table tab1 {n in 0..Nper} OUT "JSON" "Salary, Savings, and Expenses" "LineChart": 
    n~Year, 
    salary[n]~Salary,
    u[n]~Savings,
    sum{e in EXPENSES}x[n,e]~MajoExpenses;

/* print table of results */
printf "Savings as fraction of Salary: %6.4f \n\n", fSave;
printf "  n   Year  Savings   Salary   fSave   Wealth ";
printf {e in EXPENSES}: " %10s", e;
printf "\n\n";

for {n in 0..Nper} {
    printf "%3d  %5.2f  %7.0f %8.0f  %6.4f %8.0f %8.0f",
            n, n*dT, u[n], salary[n], u[n]/salary[n], w[n];
    printf {e in EXPENSES}: " %10.0f", x[n,e];
    printf "\n";
}

end;
</div>
                </div>
            </div>
        </div>



        <!-- modal Example -->
        <div id="ModalExampleNormal" class="modal" role="dialog">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div id="normal" class="modal-body modal-body-example">
/*  # Generating Random Numbers for a Multivariate Normal Distribution

Applications of optimization in finance and other fields often require
sampling of a multivariate normal distribution. We demonstrate a simple
technique for generating samples in GMPL. 

The data section defines an index set \\(I\\), population mean \\(\mu\{I\}\\),
and population covariance \\(\Sigma\{I,I\}\\).  Optionally the data section can
specify the number of samples to use in verifying the distribution.
*/

/*
Jeff Kantor 
December 4, 2009 
Revised: December 7, 2009 to add a 'seeding' of the PRNG
*/

/* Index Set */
set I;

/* Return and Covariance parameters */
param Mu {I};
param Sigma {I,I};

/* Simulation Parameters */
param N >= 1, default 50;
set T := 1..N;

/* Cholesky lower triangular decomposition */
param Chol{i in I, j in I : i >= j} := 
    if i = j then
        sqrt(Sigma[i,i]-(sum {k in I : k &lt; i} (Chol[i,k]*Chol[i,k])))
    else
        (Sigma[i,j]-sum{k in I : k &lt; j} Chol[i,k]*Chol[j,k])/Chol[j,j];

/* Because there is no way to seed the PRNG, a workaround */
param utc := prod {1..2} (gmtime()-1000000000);
param seed := utc - 100000*floor(utc/100000);
check sum{1..seed} Uniform01() > 0;

/* Compute Multivariate Normal Samples */
param z{i in I, t in T} := Normal(0,1);
param x{i in I, t in T} := Mu[i] + sum {j in I : i >= j} Chol[i,j]*z[j,t];

/* Compare sample with population statistics */
param xbar{i in I} := (1/card(T))*sum {t in T} x[i,t];
param Cov{i in I, j in I} := 
    (1/card(T))*sum {t in T} (x[i,t]-xbar[i])*(x[j,t]-xbar[j]);

/* Show results */
printf "POPULATION PARAMETERS\n\n";
printf "Mu\n";
printf {i in I} "%5s   %7.4f\n", i, Mu[i];

printf "\nSigma\n";
printf "     ";
printf {j in I} " %7s ", j;
printf "\n";
for {i in I} {
    printf "%5s  " ,i;
    printf {j in I} " %7.4f ", Sigma[i,j];
    printf "\n";
}

printf "\n\nSAMPLE STATISTICS (N = %d)\n\n",N;
printf "Mean\n";
printf {i in I} "%5s   %7.4f\n", i, xbar[i];

printf "\nCovariance\n";
printf "     ";
printf {j in I} " %7s ", j;
printf "\n";
for {i in I} {
    printf "%5s  " ,i;
    printf {j in I} " %7.4f ", Cov[i,j];
    printf "\n";
}

data;
/* Data from 3 years of monthly returns for four selected stocks. */

/* Index set I, and parameter Mu of population means */
param : I : Mu :=
    AAPL    0.0308
    GE     -0.0120
    GS      0.0027
    XOM     0.0018 ;

/* Positive Definite Sigma */
param   Sigma : 
            AAPL    GE      GS      XOM  :=
    AAPL    0.0158  0.0062  0.0088  0.0022
    GE      0.0062  0.0136  0.0064  0.0011
    GS      0.0088  0.0064  0.0135  0.0008
    XOM     0.0022  0.0011  0.0008  0.0022 ;

end;

                    </div>
                </div>
            </div>
        </div>

        <!-- modal Example -->
        <div id="ModalExamplePiecewise" class="modal" role="dialog">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div id="piecewise" class="modal-body modal-body-example">
/* # Piecewise Linear Interpolation

A common requirement is to incorporate a nonlinear constraint or objective function
into an MIP problem. Normally special ordered sets of type 2 (SOS2) are used to model
these situations, but SOS2 is not implemented in GLPK. Based on notes by Andrew 
Makhorin and Robbie Morrison, the following model demonstrates piecewise linear
interpolation in MathProg. */

param N;              # Interpolation Points
param xi{0..N};
param fi{0..N};

var z{1..N} binary;   # z[n] denotes the nth interval
var s{1..N} >= 0;

var x;
var f;

s.t. A {n in 1..N} : s[n] &lt;= z[n];
s.t. B : 1 = sum{n in 1..N} z[n];
s.t. C : x = sum{n in 1..N} (xi[n-1]*z[n] + (xi[n]-xi[n-1])*s[n]);
s.t. D : f = sum{n in 1..N} (fi[n-1]*z[n] + (fi[n]-fi[n-1])*s[n]);

maximize Objective : f;

solve;

table tab1 {n in 0..N} OUT "JSON" "Piecewise Linear Function" "LineChart" : 
    xi[n], fi[n], f~Optimum;

data;

param N := 10;

param : xi    fi  :=
    0   0.0   0.0
    1   0.1   0.12
    2   0.2   0.22
    3   0.3   0.45
    4   0.4   0.33
    5   0.5   0.50
    6   0.6   0.62
    7   0.7   0.81
    8   0.8   0.75
    9   0.9   0.72
   10   1.0   0.50 ;

end;

                    </div>
                    </div>
                </div>
            </div>


            <!-- modal Example -->
            <div id="ModalExampleSorting" class="modal" role="dialog">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div id="Sorting" class="modal-body modal-body-example">
/* # Sorting in MathProg

MathProg is a lean language with a limited number of functions and 
    utilities. Demonstrated below  are several techniques for sorting sets 
    by value of parameters or decision variables. These techniques may be 
    useful in other contexts.

These ideas are attributable to xypron and Andrew Makhorin on the 
    help-glpk mail list.
*/

set I;
param a{I};

/* Unordered Set */

printf "\nUnordered Set\n";
printf {i in I} "     %8s  %7.4f\n", i, a[i];

/* Set in Ascending Order.  r[i] computes the rank-order of corresponding 
elements in a[i].  The list is then scanned in the domain of a printf 
statement. This is an order n^3 technique which appears to be the best one can 
do in GMPL. */

printf "\nAscending Order\n";
param r{i in I} := 1 + sum {j in I} if (a[j] &lt; a[i] || a[j] == a[i] && j &lt; i) then 1;
printf {k in 1..card(I), i in I: k == r[i]}  "%3d: %8s  %7.4f\n", r[i], i, a[i];

/* Set in Descending Order with comparison within the domain spec */

printf "\nDescending Order\n";
param s{i in I} := 1 + sum {j in I : a[i] &lt; a[j] || a[i] == a[j] && i &lt; j} 1;
printf {k in 1..card(I), i in I: k == s[i]}  "%3d: %8s  %7.4f\n", s[i], i, a[i];

/* There may be instances where it would be useful to compute rank-order  in 
the optimization model, such as portfolio optimization with a VaR constraint, 
for example.  */

param BigM := 1 + sum{i in I} abs(a[i]);

var y{i in I, j in I : i&lt;>j } binary;    # y[i,j] = 0 if a[i] &lt;= a[j]
var t{i in I};                           # rank-order of a[i]

/* Pair of disjunctive constraints to force ordering of a[i] */
s.t. A{i in I, j in I : i&lt;>j}: a[i] &lt;= a[j] + BigM*y[i,j];
s.t. B{i in I, j in I : i&lt;>j}: a[j] &lt;= a[i] + BigM*(1-y[i,j]);

/* Forces a tie breaker if a[i] = a[j] */
s.t. C{i in I, j in I : i&lt;>j}: y[i,j] + y[j,i] = 1;

/* t[i] is rank-order could be computed post-solution */
s.t. D{i in I}: t[i] = 1 + sum{j in I: i&lt;>j} y[i,j];           

solve;

printf "\nAscending Order by Optimization\n";
printf {k in 1..card(I), i in I: k ==t[i]}  "%3d: %8s  %7.4f\n", t[i], i, a[i];

data;

param: I: a :=
   alpha    1
   beta     2
   gamma    2
   delta   -1.2
   chewy   -1.3
   fruity   3
   gummy   10
   doug    -3 ;

end;
                        </div>
                    </div>
                </div>
            </div>

            <!-- modal Example -->
            <div id="ModalExampleDataReconciliation" class="modal" role="dialog">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div id="DataReconciliation" class="modal-body modal-body-example">
/* # Data Reconciliation and Gross Error Detection

The following demonstration was motivated by a former student Matt N. 
who was exploring methods for assessing measurement information in a
refinery application. The illustration was adapted from Chapter 1 of 
"Reconciliation & Gross Error Detection: An Intelligent Use of Process
Data" by Shankar Narasimhan and Cornelius Jordache (Gulf Publishing,
2000).

                   1/1          2/2         4/3         6/5
                -------- SPLIT ----- HTEXG ----- MIXER --------
                           |                       ^ 
                           |                       |
                           |    3            5/4   |
                           +-------> VALVE --------+

The flow sheet is labeled by \\(s/k\\) pairs which refer to stream \\(s\\) and 
measurement \\(k\\). Streams are numbered \\(s\\) in \\(1..S\\) and sensors are numbered 
\\(k\\) in \\(1..K\\). The parameter \\(s[k]\\) denotes the stream associated with 
measurement \\(k\\).

Given sensor measurements \\(y_k\\), the task is to infer values for the
flowrates \\(x_{s_k}\\) using mass balance equations and a sensor model

\\[ \|y_k-x_{s_k}| \leq e_k + M g_k \\]
\\[ |e_k| \leq e^{max}_k \\]

\\(g_k\\) is a binary variable indicating the presence of a gross error 
in sensor \\(k\\). \\(M\\) is a big number. A gross error occurs if the 
measured data is not consistent with sensor model and mass balances. 
The optimization objective is to find an estimate of mass flows 
minimizing the number of gross sensor errors.
*/

/* Sets */
set STREAMS;
set SENSORS;
set UNITS;

/* Mass Balances  Coefficients */
param A{UNITS,STREAMS} default 0;

/* Sensors Parameters */
param y{SENSORS} >= 0;        # Measurement Data
param s{SENSORS}  > 0;        # Stream measured by each sensor
param emax{SENSORS} >= 0;     # Bound on error for each sensor
param bigM := 100;            # Big M

/* Stream Variables */
var x{STREAMS} >= 0;

/* Sensor Variables */
var epos{SENSORS} >= 0;
var eneg{SENSORS} >= 0;
var gerr{SENSORS} binary;     # Gross Errors

/* Optimization Criterion */
minimize L1: sum {k in SENSORS} (epos[k]+eneg[k] + bigM*gerr[k]);

/* Mass Balances */
s.t. MASSBAL {i in UNITS}: sum{j in STREAMS} A[i,j]*x[j] = 0;

/* Error Model */
s.t. s_err {k in SENSORS}: y[k] =  x[s[k]] + epos[k] - eneg[k];
s.t. e_pos {k in SENSORS}: epos[k] &lt;= emax[k] + bigM*gerr[k];
s.t. e_neg {k in SENSORS}: eneg[k] &lt;= emax[k] + bigM*gerr[k];

/* Solve and Display Solution */
solve;

printf "Measurement Reconciliation";
printf "\n\n   Sensor    Measured     Reconciled    Difference    GrossError";
for {k in SENSORS}{
   printf "\n      %s      %7.2f       %7.2f      %7.2f",
      k,y[k],x[s[k]],(epos[k]-eneg[k]),gerr[k];
   printf "         %3s", if gerr[k]=1 then "X" else " ";
}
printf "\n\n\nStream Estimates";
printf "\n\n   Stream    Estimate";
printf {i in STREAMS} "\n      %s      %7.2f",i,x[i];

table tab1 {k in SENSORS} OUT "JSON" "Measurement Reconciliation" "ColumnChart":
    k~Sensor,
    y[k]~Measurement,
    x[s[k]]~Reconciled;

table tab2 {k in SENSORS} OUT "JSON" "Measurement Error" "ColumnChart":
    k~Sensor,
    (epos[k]-eneg[k])~Error;

data;

/* All of the relevant sensor information is given in the data section. The
relevant information includes the number of sensors, and a table indexed by 
sensor number k with information on which stream is measured (s[k]), the 
measurement (y[k]), and  'no-penalty' range for measurement errors (emax[k]). 
*/

set UNITS := SPLIT HTEXG VALVE MIXER;
set STREAMS := 1 2 3 4 5 6;

/* Mass Balance Coefficients */
param  A :
            1   2   3   4   5   6  :=
   SPLIT   -1   1   1   .   .   .
   HTEXG    .  -1   .   1   .   .
   VALVE    .   .  -1   .   1   .
   MIXER    .   .   .   1   1  -1 ;

/* Sensors and Measurement Data*/
param: SENSORS:   s      y     emax :=    
          1       1   101.91   1.75
          2       2    68.45   1.75
          3       4    64.20   1.75
          4       5    36.44   1.75
          5       6    98.88   1.75 ;

end;</div>
                        </div>
                    </div>
                </div>


                <!-- modal Example -->
                <div id="ModalExampleSolvay" class="modal" role="dialog">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div id="solvay" class="modal-body modal-body-example">
/* # Generation-Consumption Analysis of the Solvay Process
 
The Solvay process was invented in the mid-nineteenth century for the production
of soda ash (Sodium Carbonate) from sea salt (Sodium Chloride) and limestone 
(Calcium Carbonate). Soda ash is an essential raw material for the production of 
soap, glass, textiles, and numerous inorganic products. Prior to that time these
needs were met by the production of potash from trees, which led to the deforestation
of Europe, and later the production of soda ash from the noxious LeBlance process.
In a brilliant piece of early process engineering, Ernest Solvay utilized an 
ammonia based chemistry in which the necessary chemicals are regenerated within the
process.

The following model performs a generation/consumption analysis of the four chemical
reactions comprising the Solvay process. The objective function is to maximize the
atom efficiency, which is the fraction of the total mass of raw materials that
ends up in the desired product, in this case soda ash.
*/

set ATOMS;
set SPECIES;
set REACTIONS;

param amu{ATOMS} >= 0;
param name{SPECIES} symbolic;
param formula{SPECIES,ATOMS} >= 0;
param stoich{SPECIES,REACTIONS};

# Compute Molecular Weights
param mw{s in SPECIES} := sum{a in ATOMS} amu[a]*formula[s,a];

# Check for balanced reactions
check {a in ATOMS, r in REACTIONS}: sum{s in SPECIES} stoich[s,r]*formula[s,a] = 0;

# Generation/Consumption Analysis
set RAW_MATERIALS within SPECIES;
set PRODUCTS within SPECIES;
set BYPRODUCTS := (SPECIES diff RAW_MATERIALS diff PRODUCTS);

var x{REACTIONS};
var n{SPECIES};

s.t. A {s in SPECIES} : n[s] = sum{r in REACTIONS} stoich[s,r]*x[r];
s.t. B {s in RAW_MATERIALS}: sum{r in REACTIONS} n[s] &lt;= 0;
s.t. C {s in SPECIES diff RAW_MATERIALS}: sum{r in REACTIONS} n[s] >= 0;
s.t. D : sum{s in RAW_MATERIALS} -n[s] &lt;= 1;

maximize atom_efficiency: sum{s in PRODUCTS} mw[s]*n[s];

solve;

printf "Atom Efficiency = %6.4f\n\n", 
    (sum{s in PRODUCTS} mw[s]*n[s])/(sum{s in RAW_MATERIALS} -mw[s]*n[s]);

printf "Process Stoichiometry\n";
printf "%10s",' ';
printf {r in REACTIONS} "%7s", r;
printf "%7s\n", "NET";
printf "%-10s",'Rxn Wt.';
printf {r in REACTIONS} "%7.2g", x[r];
printf "\n";
for {s in SPECIES} {
    printf "%-10s", s;
    printf {r in REACTIONS} "%7g", stoich[s,r];
    printf "%7.2g", n[s];
    printf "\n";
}
    
table chrt2 {s in RAW_MATERIALS} OUT "GCHART" "Raw Materials Consumed" "PieChart" : 
    s, -mw[s]*n[s]~Consumed;
    
table chrt3 {s in SPECIES diff RAW_MATERIALS} OUT "GCHART" "Products and By-Products Generated " "PieChart" : 
    s, mw[s]*n[s]~Generated;

table tab1 {s in RAW_MATERIALS} OUT "GCHART" "Raw Materials" "Table" : 
    name[s]~Raw_Material, s~Formula, mw[s]~MolWt, 
    sum{r in REACTIONS} max(0,(mw[s]*stoich[s,r]*x[r]))~Generated,
    sum{r in REACTIONS} max(0,-(mw[s]*stoich[s,r]*x[r]))~Consumed,
    mw[s]*n[s]~Net;

table tab1 {s in PRODUCTS} OUT "GCHART" "Products" "Table" : 
    name[s]~Product, s~Formula, mw[s]~MolWt, 
    sum{r in REACTIONS} max(0,(mw[s]*stoich[s,r]*x[r]))~Generated,
    sum{r in REACTIONS} max(0,-(mw[s]*stoich[s,r]*x[r]))~Consumed,
    mw[s]*n[s]~Net;
    
table tab3 {s in BYPRODUCTS} OUT "GCHART" "Byproducts" "Table" : 
    name[s]~Byproduct, s~Formula, mw[s]~MolWt, 
    sum{r in REACTIONS} max(0,(mw[s]*stoich[s,r]*x[r]))~Generated,
    sum{r in REACTIONS} max(0,-(mw[s]*stoich[s,r]*x[r]))~Consumed,
    mw[s]*n[s]~Net;

data;

param : ATOMS : amu :=
    C    12.011
    Ca   40.08
    Cl   35.45
    H     1.0079
    N    14.0067
    Na   22.99
    O    15.99994 
    S    32.06 ;

param : SPECIES : name := 
    NH3       Ammonia
    NH4Cl     Ammonium_Chloride
    CaCO3     Calcium_Carbonate
    CaCl2     Calcium_Chloride
    NaCl      Sodium_Chloride
    CaO       Calcium_Oxide
    CO2       Carbon_Dioxide
    Na2CO3    Sodium_Carbonate
    NaHCO3    Sodium_Bicarbonate
    H2O       Water ;

set RAW_MATERIALS := NaCl CaCO3;
set PRODUCTS := Na2CO3;

param formula default 0:
              C  Ca Cl H  N  Na O :=
    NH3       .  .  .  3  1  .  .
    NH4Cl     .  .  1  4  1  .  .
    CaCO3     1  1  .  .  .  .  3
    CaCl2     .  1  2  .  .  .  .
    NaCl      .  .  1  .  .  1  .
    CaO       .  1  .  .  .  .  1
    CO2       1  .  .  .  .  .  2
    Na2CO3    1  .  .  .  .  2  3
    NaHCO3    1  .  .  1  .  1  3
    H2O       .  .  .  2  .  .  1 ;
    
set REACTIONS := R1 R2 R3 R4;

param stoich default 0:
              R1   R2   R3   R4 :=
    NH3       -1    .    2    .
    NH4Cl      1    .   -2    .
    CaCO3      .   -1    .    . 
    CaCl2      .    .    1    .
    NaCl      -1    .    .    .
    CaO        .    1   -1    .
    CO2       -1    1    .    1
    Na2CO3     .    .    .    1
    NaHCO3     1    .    .   -2
    H2O       -1    .    1    1 ;

end;</div>
                            </div>
                        </div>
                    </div>


                    <!-- modal Example -->
                    <div id="ModalExampleMAD" class="modal" role="dialog">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div id="MAD" class="modal-body modal-body-example">
/* # Portfolio Optimization using Mean Absolute Deviation

Konno and Yamazaki (1990) proposed a linear programming model for
    portfolio optimization in which the risk measure is mean absolute 
    deviation (MAD). This model computes a portfolio minimizing MAD subject 
    to a lower bound on return.

In contrast to the classical Markowitz portfolio, the MAD criterion 
    requires a data set consisting of returns on the investment assets. The
    data set may be an historical record or samples from a multivariate 
    statistical model of portfolio returns.  The MAD criterion produces 
    portfolios with properties not shared by the Markowitz portfolio, 
    including second degree stochastic dominance.

Below we demonstrate portfolio optimization with the MAD criterion where 
    data is generated by sampling a multivariate normal distribution. Given 
    mean return \\(r\\) and the Cholesky decomposition of the covariance matrix
    \(\Sigma\) (i.e., \\(C\\) such that \\(CC^T = \Sigma\\) ), we compute
    \\(r_t = r + C z_t\\) where the elements of \\(z_t\\) are zero mean normal 
    variates with unit variance.

The rest of the formulation is adapted from "Optimization Methods in Finance"
    by Gerald Curnuejols and Reha Tutuncu (2007) which, in turn, follows an
    implementation due to Fienstein and Thapa (1993). A complete tutorial on
    the implementation of this model is available on GLPK wikibook. 
    <a rel="external" href="http://en.wikibooks.org/wiki/GLPK/Portfolio_Optimization">A 
    complete tutorial describing the implementation of this model</a> is available
    on <a rel="external" href="http://en.wikibooks.org/wiki/GLPK/">GLPK wikibook</a>.
*/

/* Stock Data */

set S;                                    # Set of stocks
param r{S};                               # Means of projected returns
param cov{S,S};                           # Covariance of projected returns
param r_portfolio
    default (1/card(S))*sum{i in S} r[i]; # Lower bound on portfolio return

/* Generate sample data */

/* Cholesky Lower Triangular Decomposition of the Covariance Matrix */
param c{i in S, j in S : i >= j} := 
    if i = j then
        sqrt(cov[i,i]-(sum {k in S : k &lt; i} (c[i,k]*c[i,k])))
    else
        (cov[i,j]-sum{k in S : k &lt; j} c[i,k]*c[j,k])/c[j,j];

/* Because there is no way to seed the PRNG, a workaround */
param utc := prod {1..2} (gmtime()-1000000000);
param seed := utc - 100000*floor(utc/100000);
check sum{1..seed} Uniform01() > 0;

/* Normal random variates */
param N default 5000;
set T := 1..N;
param zn{j in S, t in T} := Normal(0,1);
param rt{i in S, t in T} := r[i] + sum {j in S : j &lt;= i} c[i,j]*zn[j,t];

/* MAD Optimization */

var w{S} >= 0;                # Portfolio Weights with Bounds
var y{T} >= 0;                # Positive deviations (non-negative)
var z{T} >= 0;                # Negative deviations (non-negative)

minimize MAD: (1/card(T))*sum {t in T} (y[t] + z[t]);

s.t. C1: sum {s in S} w[s]*r[s] >= r_portfolio;
s.t. C2: sum {s in S} w[s] = 1;
s.t. C3 {t in T}: (y[t] - z[t]) = sum{s in S} (rt[s,t]-r[s])*w[s];

solve;

/* Report */

/* Input Data */
printf "Stock Data\n\n";
printf "         Return   Variance\n";
printf {i in S} "%5s   %7.4f   %7.4f\n", i, r[i], cov[i,i];

printf "\nCovariance Matrix\n\n";
printf "     ";
printf {j in S} " %7s ", j;
printf "\n";
for {i in S} {
    printf "%5s  " ,i;
    printf {j in S} " %7.4f ", cov[i,j];
    printf "\n";
}

/* MAD Optimal Portfolio */
printf "\nMinimum Absolute Deviation (MAD) Portfolio\n\n";
printf "  Return   = %7.4f\n",r_portfolio;
printf "  Variance = %7.4f\n\n", sum {i in S, j in S} w[i]*w[j]*cov[i,j];
printf "         Weight\n";
printf {s in S} "%5s   %7.4f\n", s, w[s];
printf "\n";

table tab0 {s in S} OUT "JSON" "Optimal Portfolio" "PieChart": 
    s, w[s]~PortfolioWeight;
    
table tab1 {s in S} OUT "JSON" "Asset Return versus Volatility" "ScatterChart":
    sqrt(cov[s,s])~StDev, r[s]~Return;
    
table tab2 {s in S} OUT "JSON" "Portfolio Weights" "ColumnChart": 
    s~Stock, w[s]~PortfolioWeight;
    
table tab3 {t in T} OUT "JSON" "Simulated Portfolio Return" "LineChart": 
    t~month, (y[t] - z[t])~PortfolioReturn;

/* Simulated Return data in Matlab Format */
/*
printf "\nrt = [ ... \n";
for {t in T} {
   printf {s in S} "%9.4f",rt[s,t];
   printf "; ...\n";
}
printf "];\n\n";
*/

data;

/* Data for monthly returns on four selected stocks for a three
year period ending December 4, 2009 */

param N := 200;

param r_portfolio := 0.01;

param : S : r :=
    AAPL    0.0308
    GE     -0.0120
    GS      0.0027
    XOM     0.0018 ;

param   cov : 
            AAPL    GE      GS      XOM  :=
    AAPL    0.0158  0.0062  0.0088  0.0022
    GE      0.0062  0.0136  0.0064  0.0011
    GS      0.0088  0.0064  0.0135  0.0008
    XOM     0.0022  0.0011  0.0008  0.0022 ;

end;
                                </div>
                            </div>
                        </div>
                    </div>



                    <!-- modal Example -->
                    <div id="ModalExamplePlantExpansion" class="modal" role="dialog">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div id="PlantExpansion" class="modal-body modal-body-example">
/* # Scenario Analysis for a Plant Expansion

Description to be written. Problem Data from Johannes Bisschop, "AIMMS 
    Optimization Modeling", Paragon Decision Sciences, 1999.
*/


set PLANTS;                            # Set of plant types
set DEMAND;                            # Demand Segments
set SCENARIOS;                         # Planning Scenarios

param e{PLANTS};                       # Current Plant Capacity
param C{PLANTS};                       # Capital Cost per unit Expansion
param O{PLANTS};                       # Operating Cost [k$/GWh]

param T{DEMAND};                       # Time Periods for Demand Segments
param D{DEMAND,SCENARIOS};             # Demand Scenarios

var x {PLANTS} >= 0;                   # Plant Expansion
var y {PLANTS,DEMAND,SCENARIOS} >= 0;  # Operating Schedule
var v {SCENARIOS};                     # Variable Cost
var capcost;                           # Capital Cost

minimize COST: capcost + sum {s in SCENARIOS} 0.25*v[s];

s.t. CAPCOST: capcost = sum{p in PLANTS} C[p]*(e[p]+x[p]);
s.t. VARCOST {s in SCENARIOS}:
   v[s] = sum {p in PLANTS, d in DEMAND} T[d]*O[p]*y[p,d,s];
s.t. DEMANDS {p in PLANTS, s in SCENARIOS}: 
   e[p] + x[p] >= sum {d in DEMAND} y[p,d,s];
s.t. C4 {d in DEMAND, s in SCENARIOS} :
   D[d,s] = sum {p in PLANTS} y[p,d,s];
   
solve;

table results {p in PLANTS} OUT "JSON" "Optimal Expansion" "Table" :
    p~Plant,
    O[p]~Unit_Cost,
    e[p]~Current_Cap,
    x[p]~Exp_Cap,
    x[p]+e[p]~Total_Cap;

data;

set SCENARIOS := S1 S2 S3 S4;

param: DEMAND: T :=
    Base      24
    Peak       6 ;

param: PLANTS:     e     C     O:=
    Coal        1.75   200    30
    Hydro       2.00   500    10
    Nuclear     0.00   300    20
    Grid        0.00     0   200 ;

param D :   S1     S2    S3    S4 :=
    Base   8.25   10.0  7.50  9.00
    Peak   2.50   2.00  2.50  1.50 ;

end;
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- modal Example -->
                    <div id="ModalExampleGambling" class="modal" role="dialog">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div id="RNGambling" class="modal-body modal-body-example">
                                    /*
## Stochastic Dynamic Programming: Risk Neutral Gambler

### Problem Statement

The risk neutral gambler enters a game with the idea of betting until 
he or she is either reaches a goal \\(N\\) or runs out of money.
Given a stake \\(x\\) and wager \\(u\\), the result is a stake that is either 
\\(x+u\\) with probability \\(p\\), or a stake \\(x-u\\) with probability \\(q\\).
The probabilities sastisfy the inequality

\\[p + q \leq 1\\]

The wager must be smaller than the stake or any maximum wager established for 
the game.  To encourage risk taking, the future value of money is discounted 
by a factor \\(a \leq 1\\).  

Given an initial stake \\(x &lt; N\\), what is the optimal gambling strategy?

### Formulation

This classic problem in Dynamic Programming is discussed, for example, by 
Sutton and Barto in "Reinforcement Learning" (MIT Press, 1998). The function
\\(V(k,x)\\) is the expected value of the game after the kth wager and with a
stake \\(x\\). If the gambler reaches the goal of winning a stake \\(N\\) at
\\(k\\) then the value of the game is \\(V(k,N) = N\\). Or if the gamble
loses everything, then \\(V(k,0) = 0\\). Otherwise, for \\(x &lt; N\\), the
Bellman equation for optimality provides the recursion

\\[V(k-1,x) = a \max_u  [ p V(k,x+u) + q V(k,x-u) ]\\]

where \\(a\\) is the discount factor for future values. The maximization is
over the set of possible bets ranging from \\(0\\) to the minimum of \\(x\\),
\\(N-x\\), or the bet limit \\(B\\). Note that the state space and set of
control actions are finite.

### Solution by Linear Programming

The optimality equation can be solved by well known methods for policy 
iteration.  Alternatively, as shown for example by Ross in "Introduction to 
Stochastic Dynamic Programming" (Academic Press, 1983), an exact solution can 
be found by linear programming. We seek a stationary solution \\(V[x]\\) by 
minimizing \\(\sum_{x \in 0..N} V[x]\\)  subject to 

\\[V[x] \geq a (p V[x + u] + q V[x-u])\\]

for all feasible bets and all \\(x \\in 1..N-1\\) with boundary conditions \\(V[0] = 0\\) 
and \\(V[N] = N\\).  The set of optimal wagers \\(u[x]\\) are found by determing the
constraints that are active at optimality.  \\(u[x]\\) may have multiple values.*/

/* Problem Parameters.  Any of these can be adjusted in a data section.  */

param N default 100, >= 1;               # Goal
param p default 0.25, >= 0, &lt;= 1;        # Winning probability
param q default 1-p, >= 0, &lt;= 1-p;       # Losing probability
param B default N, >= 1, &lt;= N;           # Maximum wager size
param a default 1, >= 0, &lt;= 1;           # Discount factor

/* Set of States */

set X:= 0..N;

/* Sets of possible wagers. These are parameterized by the State */

set U{x in X} := 1..min(B,min(N-x,x));

/* Value function */

var V{X};

/* Exact Linear Program Equivalent of the DP */

minimize OBJ: sum{x in X} V[x] ;

s.t. C1 {x in 1..N-1, u in U[x]}: V[x] >=  a*(p*V[x+u] + q*V[x-u]);
s.t. C2: V[0] = 0;
s.t. C3: V[N] = N;

solve;

table tab1 {x in X} OUT "JSON" "Expected Value of the Initial Stake" "LineChart" : 
    x~Stake, V[x]~ExpectedValue;

printf "               Goal = %4d", N;
printf "\n        Maximum Bet = %4d", B;
printf "\nWinning Probability = %8.3f", p ;
printf "\n Losing Probability = %8.3f", q ;
printf "\n    Discount Factor = %8.3f", a;
printf "\n\n %7s  %10s   %4s\n",'x','V[x]','u[x]: Optimal Wagers';
printf     " %7s  %10s   %4s"  ,'-','----','---------------------';
for {x in X}{
   printf "\n %7d  %10.4f  ",x, V[x];
   printf {u in U[x]: abs(-V[x] + a*(p*V[x+u] + q*V[x-u])) &lt; 0.00001} " %3d",u;
}

end;
 </div>
                                </div>
                            </div>
                        </div>


                        <!-- modal Example -->
                        <div id="ModalExampleRAGambling" class="modal" role="dialog">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <div id="RAGambling" class="modal-body modal-body-example">
                                     /* # Stochastic Dynamic Programming: The Risk Averse Gambler

## Problem Statement

A risk averse gambler with enters a game with the idea
    of betting for a fixed number of rounds \\(T\\). With a stake \\(x\\) and wager
    \\(u\\), the resulting state is either \\(x+u\\) with probability \\(p\\), or 
    \\(x-u\\) with probability \\(q\\) where \\[p + q \leq 1\\] The wager must be
    an integer smaller than the current stake or the maximum wager established
    for the game. The total stake is limited to an amount \\(N\\). The gambler
    is risk averse where utility of the final stake is \\(\log(x)\\). Given an
    initial stake \\(x &lt; N\\), calculate a strategy that maximizes the expected
    utility at the end of the game.

## Formulation of a Solution

This is a classic problem in Stochastic Dynamic Programming. The 
    function \\(V(k,x)\\) is the expected utility after of stake \\(x\\) after the 
    \\(k^{th}\\) wager. The expected utility satisfies the optimality equation
    \\[V(k,x) = max_u [ p V(k+1,x+u) + q V(k+1,x-u) ]\\] where \\(V(T,x) = 
    \log(x)\\). The maximization is over the set of possible bets ranging from 
    \\(0\\) to the minimum of \\(x\\), \\(N-x\\), or the bet limit \\(B\\). Note that 
    the state space and set of control actions are finite.


## Solution by Linear Programming

The optimality equation can be solved by well known methods for policy 
    iteration.  Alternatively, as shown for example by Ross in "Introduction to 
    Stochastic Dynamic Programming" (Academic Press, 1983), an exact solution can 
    be found by linear programming. We seek a solution \\(V[k,x]\\) minimizing
    \\[\sum_{k=0}^{T-1}\sum_{x=0}^N V[k,x]\\]  subject to 
    \\[V[k,x] \geq p V[k+1,x+u] + q V[k+1,x-u]\\]
    for all feasible bets and boundary condition \\(V[T,x] = \log(x)\\). The set of 
    optimal wagers \\(u[x]\\) are found by determining the constraints that are 
    active at optimality.
*/

/*
Jeff Kantor
December 18, 2009
*/

/* Problem Parameters.  Any of these can be adjusted in a data section.  */

param T default 5 >= 1;              # Stages
param N default 50, >= 1;            # Maximum Stake (reduce if computations are slow)
param p default 0.55, >= 0, &lt;= 1;    # Winning probability
param q default 1-p, >= 0, &lt;= 1-p;   # Losing probability
param B default N, >= 1, &lt;= N;       # Maximum wager size

/* Set of States */

set X:= 1..N;

/* Sets of possible wagers. These are parameterized by the State */

set U{x in X} := 0..min(B,min(N-x,x-1));

/* Value function */

var V{0..T,X}>=0;

/* Exact Linear Program Equivalent of the DP */

minimize OBJ: sum{t in 0..T-1, x in X} V[t,x] ;

s.t. C1 {t in 0..T-1, x in 1..N, u in U[x]}:
   V[t,x] >=  p*V[t+1,x+u] + q*V[t+1,x-u];
s.t. C2 {x in X}: V[T,x] = log(x);

solve;

/* Find Optimal Wager */
param w{t in 0..T-1,x in 1..N} := 
   if x==N then 0
   else min{u in U[x]:
      abs(-V[t,x]+p*V[t+1,x+u]+q*V[t+1,x-u])&lt;0.000001} u;

table tab1 {x in X} OUT "JSON" "Optimal Wager" "LineChart" : 
    x, w[T-1,x]~Wager;
    
table tab2 {x in X} OUT "JSON" "Expected Utility of the Initial Stake" "LineChart" :
    x, exp(V[T-1,x])~ExpectedUtility;

printf "   Number of Wagers = %4d\n", T;
printf "      Maximum Stake = %4d\n", N;
printf "        Maximum Bet = %4d\n", B;
printf "Winning Probability = %8.3f\n", p ;
printf " Losing Probability = %8.3f\n", q ;
printf "\n  %7s ",' ';
printf {t in 0..T-1} "   Wager %2s  ", t+1;
printf "\n %7s ",'Stake';
printf {t in 0..T-1} "   CE[x] u[x]";
printf "\n %7s ",'-----';
printf {t in 0..T-1} "   %9s ", '---------';
for {x in X}{
   printf "\n %7d", x;
   printf {t in 0..T-1} "   %6.2f %3d", exp(V[t,x]), w[t,x];
}

end; 
                                    </div>
                                    </div>
                                </div>
                            </div>



                            <!-- container -->
                            <div id='container'>

                                <!-- Navigation Menu Bar -->
                                <nav class="navbar navbar-default">
                                    <div class="container-fluid">
                                        <div class="navbar-header">
                                            <a class="navbar-brand" href="#">Solver MathProg</a>
                                        </div>

                                        <!-- Models menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="dropdown">
                                                <a href="#" id="models-menu">Modelo <span class="caret"></span></a>
                                                <ul class="dropdown-menu">
                                                    <li><a href="#" id="menuNew" onclick="document.getElementById('btnNewModel').click()">Novo</a></li>
                                                    <li><a href="#" id="menuOpen" onclick="document.getElementById('btnOpenModel').click()">Abrir ...</a></li>
                                                    <li><a href="#" id="menuSave">Salvar</a></li>
                                                </ul>
                                            </li>
                                        </ul>

                                        <!-- Examples menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="dropdown">
                                                <a href="#" id="examples-menu">Exemplos <span class="caret"></span></a>
                                                <ul class="dropdown-menu">

                                                    <li class="dropdown-submenu">
                                                        <a href="#">MathProg - B&aacute;sicos <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="ExampleHelloWorldMenu" onclick="copiarExemplo('helloWorld');">Olá, Mundo</a></li>
                                                            <li><a id="lpTwoVarsMenu" onclick="copiarExemplo('lpTwoVars');">Programa Linear em Duas Variáveis</a></li>
                                                            <li><a id="linearEqnsMenu" onclick="copiarExemplo('linearEqns');">Equações Lineares</a></li>
                                                            <li><a id="setsMenu" onclick="copiarExemplo('sets');">Conjuntos</a></li>
                                                            <li><a id="parametersMenu" onclick="copiarExemplo('parameters');">Parâmetros</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href="#">Tabelas e Gr&aacute;ficos <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="ChartToolsMenu" onclick="copiarExemplo('chartTools');">Gráficos do Google</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Agendamento <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="projectCPMMenu" onclick="copiarExemplo('ProjectCPM');">Gestão de Projetos com CPM</a></li>
                                                            <li><a id="jobShopMenu" onclick="copiarExemplo('jobShop');">Escala para Trabalho em Lojas</a></li>
                                                            <li><a id="JesuitVolsMenu" onclick="copiarExemplo('Jesuit');">Corpo de Voluntários Jesuítas</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Transporte e Atribui&ccedil;&otilde;es <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="TransportNetMenu" onclick="copiarExemplo('transportationNetwork');">Rede de Transporte</a></li>
                                                            <li><a id="StockCuttingMenu" onclick="copiarExemplo('StockCutting');">Redução de Estoque</a></li>
                                                            <li><a id="TableSeatingMenu" onclick="copiarExemplo('tableSeating');">Lugares à Mesa</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Rota otimizada <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="tsptwMenu" onclick="copiarExemplo('tsptw');">Tempo de Viagem do Caixeiro Viajante</a></li>
                                                            <li><a id="vrpMenu" onclick="copiarExemplo('vrp');">Roteamento de Veículos</a></li>
                                                            <li><a id="vrptwMenu" onclick="copiarExemplo('vrptw');">Tempo da Rota Veicular</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Programação Estoc&aacute;stica <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="NewsvendorMenu" onclick="copiarExemplo('theNewsvendorProblem');">Problema do Vendedor de Notícias</a></li>
                                                            <li><a id="PlantExpMenu" onclick="copiarExemplo('PlantExpansion');">Análise de Cenário para uma Expansão de Fábrica</a></li>
                                                            <li><a id="RNGamblingMenu" onclick="copiarExemplo('RNGambling');">Programação Dinâmica Estocástica: Jogador Neutro ao Risco</a></li>
                                                            <li><a id="RAGamblingMenu" onclick="copiarExemplo('RAGambling')">Programação Dinâmica Estocástica: Jogador Avesso ao Risco</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Engenharia <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="DataReconciliationMenu" onclick="copiarExemplo('DataReconciliation');">Reconciliação de Dados</a></li>
                                                            <li><a id="SolvayMenu" onclick="copiarExemplo('solvay');">Análise de Geração / Consumo</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Finan&ccedil;as <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="retirMenu" onclick="copiarExemplo('retirement');">Poupança para a Aposentadoria</a></li>
                                                            <li><a id="PortfolioMADMenu" onclick="copiarExemplo('MAD');">Otimização de Portfólio (MAD)</a></li>
                                                            <li><a id="AmericanCallMenu" onclick="copiarExemplo('BPMACO');">Opção de Compra Americana</a></li>
                                                            <li><a id="AmericanPutMenu" onclick="copiarExemplo('BPMAPO');">Opção de Venda Americana</a></li>
                                                            <li><a id="EuropeanCallMenu" onclick="copiarExemplo('BPMECO');">Opção de Compra Europeia</a></li>
                                                            <li><a id="EuropeanPutMenu" onclick="copiarExemplo('BPMEPO');">Opção de Venda Europeia</a></li>
                                                            <li><a id="PoliticalMenu" onclick="copiarExemplo('PoliticalArb');">Arbitragem em Mercados Políticos</a></li>
                                                            <li><a id="RiskNeutralAIMenu" onclick="copiarExemplo('RiskNeutral');">Probabilidades de Risco Neutro para American Idol</a></li>
                                                        </ul>
                                                    </li>


                                                    <li class="dropdown-submenu">
                                                        <a href='#'>T&eacute;cnicas Avan&ccedil;adas <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="MVNormalMenu" onclick="copiarExemplo('Normal');">Amostragem de uma Distribuição Normal Multivariada</a></li>
                                                            <li><a id="PiecewiseLinearInterpolationMenu" onclick="copiarExemplo('piecewise');">Interpolação Linear por Partes</a></li>
                                                            <li><a id="SortMenu" onclick="copiarExemplo('Sorting')">Ordenação</a></li>
                                                        </ul>
                                                    </li>

                                                </ul>
                                            </li>
                                        </ul>

                                        <!-- MathProg Resources menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="dropdown">
                                                <a href="#" id="resources-menu">Recursos <span class="caret"></span></a>
                                                <ul class="dropdown-menu">
                                                    <li><a rel="external" href='https://github.com/jckantor/MathProg-Solver/blob/master/libs/glpk-4.60/doc/gmpl.pdf'>Projeto Original - GNU MathProg</a></li>
                                                    <li><a rel="external" href='http://en.wikibooks.org/wiki/GLPK/GMPL_(MathProg)'>Wiki MathProg</a></li>
                                                    <li><a rel="external" href='http://www.ampl.com/BOOK/download.html'>Livro sobre AMPL</a></li>
                                                    <li><a rel="external" href='http://iuuk.mff.cuni.cz/~bohm/texts/mathprog_intro.html'>MathProg em 60</a></li>
                                                </ul>
                                            </li>
                                        </ul>

                                        <!-- Sobre ... menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="active">
                                                <a id='menuAbout' href="#">Sobre</a>
                                            </li>
                                        </ul>

                                    </div>
                                    <!-- /.navbar-inner -->
                                </nav>
                                <!-- /.navbar-->

                                <div id='content'>

                                    <!-- Model Editor -->
                                    <div id='divModelFileName'>
                                        <h4>Nome do arquivo</h4>
                                        <input type="text" id='modelFileName' class="NomeArquivo">
                                    </div>
                                    <textarea id='editor'></textarea><br>

                                    <!-- Button Bar -->
                                    <div id='btnBar'>
                                        <div class="btn-group">
                                            <button class="btn btn-primary bordaRedonda" id='btnNewModel' title='Limpar alterações e cria um novo modelo.'>Novo Modelo</button>
                                            <button class="btn btn-primary bordaRedonda" id='btnOpenModel' title='Abrir modelo de um arquivo.'>Abrir Modelo...</button>
                                            <input type="file" id="inputOpenModel" name="inputOpenModel[]">
                                            <button class="btn btn-primary bordaRedonda" id='btnSaveModel' title='Salvar modelo em um arquivo.'>Salvar Modelo...</button>
                                        </div>
                                        <button class="btn btn-success" id='btnSolveModel' title='Calcular uma solução para o modelo.'>Resolver</button>
                                    </div>
                                    <br>

                                    <!-- Message Panel -->
                                    <div id="messagePanel">
                                        <div id="message" class="alert"></div>
                                    </div>

                                    <!-- Output Tabs -->
                                    <div class="tabbable">
                                        <ul class="nav nav-tabs">
                                            <li class="active">
                                                <a href="#tab1" data-toggle="tab">
                                                    <h4 class="bottom-panel">Painel de Controle</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#outputTab" data-toggle="tab">
                                                    <h4 class="bottom-panel">Sa&iacute;da</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#dataTab" data-toggle="tab">
                                                    <h4 class="bottom-panel">Dados</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#variableTab" data-toggle="tab">
                                                    <h4 class="bottom-panel">Vari&aacute;veis</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#constraintTab" data-toggle="tab">
                                                    <h4 class="bottom-panel">Restri&ccedil;&otilde;es</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#tab5" data-toggle="tab">
                                                    <h4 class="bottom-panel">Registros</h4>
                                                </a>
                                            </li>
                                        </ul>

                                        <div class="tab-content">

                                            <!-- Dashboard Pane -->
                                            <div class="tab-pane active" id="tab1">
                                                <div id='dashboardPanel'>
                                                    <table id='dashboardTable' class="table table-condensed table-bordered table-hover">
                                                        <tr>
                                                            <td>Tipo de Problema</td>
                                                            <td id="dashboardProb" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Objetivo</td>
                                                            <td id="dashboardObj" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Valor Objetivo</td>
                                                            <td id="dashboardObjVal" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Vari&aacute;veis Cont&iacute;nuas</td>
                                                            <td id="dashboardNvars" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Vari&aacute;veis inteiras n&atilde;o bin&eacute;rias</td>
                                                            <td id="dashboardNints" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Vari&aacute;veis bin&aacute;rias</td>
                                                            <td id="dashboardNbins" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>N&uacute;mero de Vari&aacute;veis</td>
                                                            <td id="dashboardNcols" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>N&uacute;mero de Restri&ccedil;&otilde;es</td>
                                                            <td id="dashboardNrows" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>N&uacute;mero de coeficientes n&atilde;o zero</td>
                                                            <td id="dashboardNnz" class="dashboardCell"></td>
                                                        </tr>
                                                    </table>
                                                </div>
                                            </div>

                                            <!-- Model Output Pane -->
                                            <div class="tab-pane" id="outputTab"></div>

                                            <!-- Data Sources Pane -->
                                            <div class="tab-pane" id="dataTab"></div>

                                            <!-- Variables Pane -->
                                            <div class="tab-pane" id="variableTab">
                                                <table class="table table-striped table-condensed" id="variableTableDiv"></table>
                                            </div>

                                            <!-- Constraints Pane -->
                                            <div class="tab-pane" id="constraintTab">
                                                <table class="table table-striped table-condensed" id="constraintTableDiv"></table>
                                            </div>

                                            <!-- GLPK Log Pane-->
                                            <div class="tab-pane" id="tab5">
                                                <pre id='logContent'></pre><br>
                                            </div>

                                        </div>
                                        <!-- end of tab-content -->
                                    </div>
                                    <!-- end of tabtable -->
                                </div>
                                <!-- end of content -->

                            </div>
                            <!-- end of container -->

                            <script src="js/main.js"></script>

</body>

</html>
